{"version":3,"file":"drawingLayer-a4e13dd5.js","sources":["../../node_modules/ol/layer/Vector.js","../../node_modules/ol/geom/Circle.js","../../node_modules/ol/interaction/Draw.js","../../src/components/maps/drawingLayer.tsx"],"sourcesContent":["/**\n * @module ol/layer/Vector\n */\nimport BaseVectorLayer from './BaseVector.js';\nimport CanvasVectorLayerRenderer from '../renderer/canvas/VectorLayer.js';\n\n/**\n * @classdesc\n * Vector data is rendered client-side, as vectors. This layer type provides most accurate rendering\n * even during animations. Points and labels stay upright on rotated views. For very large\n * amounts of vector data, performance may suffer during pan and zoom animations. In this case,\n * try {@link module:ol/layer/VectorImage~VectorImageLayer}.\n *\n * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}\n * property on the layer object; for example, setting `title: 'My Title'` in the\n * options means that `title` is observable, and has get/set accessors.\n *\n * @template {import(\"../source/Vector.js\").default} VectorSourceType\n * @extends {BaseVectorLayer<VectorSourceType, CanvasVectorLayerRenderer>}\n * @api\n */\nclass VectorLayer extends BaseVectorLayer {\n  /**\n   * @param {import(\"./BaseVector.js\").Options<VectorSourceType>} [options] Options.\n   */\n  constructor(options) {\n    super(options);\n  }\n\n  createRenderer() {\n    return new CanvasVectorLayerRenderer(this);\n  }\n}\n\nexport default VectorLayer;\n","/**\n * @module ol/geom/Circle\n */\nimport SimpleGeometry from './SimpleGeometry.js';\nimport {createOrUpdate, forEachCorner, intersects} from '../extent.js';\nimport {deflateCoordinate} from './flat/deflate.js';\nimport {rotate} from './flat/transform.js';\n\n/**\n * @classdesc\n * Circle geometry.\n *\n * @api\n */\nclass Circle extends SimpleGeometry {\n  /**\n   * @param {!import(\"../coordinate.js\").Coordinate} center Center.\n   *     For internal use, flat coordinates in combination with `layout` and no\n   *     `radius` are also accepted.\n   * @param {number} [radius] Radius in units of the projection.\n   * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\n   */\n  constructor(center, radius, layout) {\n    super();\n    if (layout !== undefined && radius === undefined) {\n      this.setFlatCoordinates(layout, center);\n    } else {\n      radius = radius ? radius : 0;\n      this.setCenterAndRadius(center, radius, layout);\n    }\n  }\n\n  /**\n   * Make a complete copy of the geometry.\n   * @return {!Circle} Clone.\n   * @api\n   */\n  clone() {\n    const circle = new Circle(\n      this.flatCoordinates.slice(),\n      undefined,\n      this.layout\n    );\n    circle.applyProperties(this);\n    return circle;\n  }\n\n  /**\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @param {import(\"../coordinate.js\").Coordinate} closestPoint Closest point.\n   * @param {number} minSquaredDistance Minimum squared distance.\n   * @return {number} Minimum squared distance.\n   */\n  closestPointXY(x, y, closestPoint, minSquaredDistance) {\n    const flatCoordinates = this.flatCoordinates;\n    const dx = x - flatCoordinates[0];\n    const dy = y - flatCoordinates[1];\n    const squaredDistance = dx * dx + dy * dy;\n    if (squaredDistance < minSquaredDistance) {\n      if (squaredDistance === 0) {\n        for (let i = 0; i < this.stride; ++i) {\n          closestPoint[i] = flatCoordinates[i];\n        }\n      } else {\n        const delta = this.getRadius() / Math.sqrt(squaredDistance);\n        closestPoint[0] = flatCoordinates[0] + delta * dx;\n        closestPoint[1] = flatCoordinates[1] + delta * dy;\n        for (let i = 2; i < this.stride; ++i) {\n          closestPoint[i] = flatCoordinates[i];\n        }\n      }\n      closestPoint.length = this.stride;\n      return squaredDistance;\n    }\n    return minSquaredDistance;\n  }\n\n  /**\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @return {boolean} Contains (x, y).\n   */\n  containsXY(x, y) {\n    const flatCoordinates = this.flatCoordinates;\n    const dx = x - flatCoordinates[0];\n    const dy = y - flatCoordinates[1];\n    return dx * dx + dy * dy <= this.getRadiusSquared_();\n  }\n\n  /**\n   * Return the center of the circle as {@link module:ol/coordinate~Coordinate coordinate}.\n   * @return {import(\"../coordinate.js\").Coordinate} Center.\n   * @api\n   */\n  getCenter() {\n    return this.flatCoordinates.slice(0, this.stride);\n  }\n\n  /**\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @protected\n   * @return {import(\"../extent.js\").Extent} extent Extent.\n   */\n  computeExtent(extent) {\n    const flatCoordinates = this.flatCoordinates;\n    const radius = flatCoordinates[this.stride] - flatCoordinates[0];\n    return createOrUpdate(\n      flatCoordinates[0] - radius,\n      flatCoordinates[1] - radius,\n      flatCoordinates[0] + radius,\n      flatCoordinates[1] + radius,\n      extent\n    );\n  }\n\n  /**\n   * Return the radius of the circle.\n   * @return {number} Radius.\n   * @api\n   */\n  getRadius() {\n    return Math.sqrt(this.getRadiusSquared_());\n  }\n\n  /**\n   * @private\n   * @return {number} Radius squared.\n   */\n  getRadiusSquared_() {\n    const dx = this.flatCoordinates[this.stride] - this.flatCoordinates[0];\n    const dy = this.flatCoordinates[this.stride + 1] - this.flatCoordinates[1];\n    return dx * dx + dy * dy;\n  }\n\n  /**\n   * Get the type of this geometry.\n   * @return {import(\"./Geometry.js\").Type} Geometry type.\n   * @api\n   */\n  getType() {\n    return 'Circle';\n  }\n\n  /**\n   * Test if the geometry and the passed extent intersect.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @return {boolean} `true` if the geometry and the extent intersect.\n   * @api\n   */\n  intersectsExtent(extent) {\n    const circleExtent = this.getExtent();\n    if (intersects(extent, circleExtent)) {\n      const center = this.getCenter();\n\n      if (extent[0] <= center[0] && extent[2] >= center[0]) {\n        return true;\n      }\n      if (extent[1] <= center[1] && extent[3] >= center[1]) {\n        return true;\n      }\n\n      return forEachCorner(extent, this.intersectsCoordinate.bind(this));\n    }\n    return false;\n  }\n\n  /**\n   * Set the center of the circle as {@link module:ol/coordinate~Coordinate coordinate}.\n   * @param {import(\"../coordinate.js\").Coordinate} center Center.\n   * @api\n   */\n  setCenter(center) {\n    const stride = this.stride;\n    const radius = this.flatCoordinates[stride] - this.flatCoordinates[0];\n    const flatCoordinates = center.slice();\n    flatCoordinates[stride] = flatCoordinates[0] + radius;\n    for (let i = 1; i < stride; ++i) {\n      flatCoordinates[stride + i] = center[i];\n    }\n    this.setFlatCoordinates(this.layout, flatCoordinates);\n    this.changed();\n  }\n\n  /**\n   * Set the center (as {@link module:ol/coordinate~Coordinate coordinate}) and the radius (as\n   * number) of the circle.\n   * @param {!import(\"../coordinate.js\").Coordinate} center Center.\n   * @param {number} radius Radius.\n   * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\n   * @api\n   */\n  setCenterAndRadius(center, radius, layout) {\n    this.setLayout(layout, center, 0);\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = [];\n    }\n    /** @type {Array<number>} */\n    const flatCoordinates = this.flatCoordinates;\n    let offset = deflateCoordinate(flatCoordinates, 0, center, this.stride);\n    flatCoordinates[offset++] = flatCoordinates[0] + radius;\n    for (let i = 1, ii = this.stride; i < ii; ++i) {\n      flatCoordinates[offset++] = flatCoordinates[i];\n    }\n    flatCoordinates.length = offset;\n    this.changed();\n  }\n\n  getCoordinates() {\n    return null;\n  }\n\n  setCoordinates(coordinates, layout) {}\n\n  /**\n   * Set the radius of the circle. The radius is in the units of the projection.\n   * @param {number} radius Radius.\n   * @api\n   */\n  setRadius(radius) {\n    this.flatCoordinates[this.stride] = this.flatCoordinates[0] + radius;\n    this.changed();\n  }\n\n  /**\n   * Rotate the geometry around a given coordinate. This modifies the geometry\n   * coordinates in place.\n   * @param {number} angle Rotation angle in counter-clockwise radians.\n   * @param {import(\"../coordinate.js\").Coordinate} anchor The rotation center.\n   * @api\n   */\n  rotate(angle, anchor) {\n    const center = this.getCenter();\n    const stride = this.getStride();\n    this.setCenter(\n      rotate(center, 0, center.length, stride, angle, anchor, center)\n    );\n    this.changed();\n  }\n}\n\n/**\n * Transform each coordinate of the circle from one coordinate reference system\n * to another. The geometry is modified in place.\n * If you do not want the geometry modified in place, first clone() it and\n * then use this function on the clone.\n *\n * Internally a circle is currently represented by two points: the center of\n * the circle `[cx, cy]`, and the point to the right of the circle\n * `[cx + r, cy]`. This `transform` function just transforms these two points.\n * So the resulting geometry is also a circle, and that circle does not\n * correspond to the shape that would be obtained by transforming every point\n * of the original circle.\n *\n * @param {import(\"../proj.js\").ProjectionLike} source The current projection.  Can be a\n *     string identifier or a {@link module:ol/proj/Projection~Projection} object.\n * @param {import(\"../proj.js\").ProjectionLike} destination The desired projection.  Can be a\n *     string identifier or a {@link module:ol/proj/Projection~Projection} object.\n * @return {Circle} This geometry.  Note that original geometry is\n *     modified in place.\n * @function\n * @api\n */\nCircle.prototype.transform;\nexport default Circle;\n","/**\n * @module ol/interaction/Draw\n */\nimport Circle from '../geom/Circle.js';\nimport Event from '../events/Event.js';\nimport EventType from '../events/EventType.js';\nimport Feature from '../Feature.js';\nimport GeometryCollection from '../geom/GeometryCollection.js';\nimport InteractionProperty from './Property.js';\nimport LineString from '../geom/LineString.js';\nimport MapBrowserEvent from '../MapBrowserEvent.js';\nimport MapBrowserEventType from '../MapBrowserEventType.js';\nimport MultiLineString from '../geom/MultiLineString.js';\nimport MultiPoint from '../geom/MultiPoint.js';\nimport MultiPolygon from '../geom/MultiPolygon.js';\nimport Point from '../geom/Point.js';\nimport PointerInteraction from './Pointer.js';\nimport Polygon, {fromCircle, makeRegular} from '../geom/Polygon.js';\nimport VectorLayer from '../layer/Vector.js';\nimport VectorSource from '../source/Vector.js';\nimport {FALSE, TRUE} from '../functions.js';\nimport {\n  always,\n  never,\n  noModifierKeys,\n  shiftKeyOnly,\n} from '../events/condition.js';\nimport {\n  boundingExtent,\n  getBottomLeft,\n  getBottomRight,\n  getTopLeft,\n  getTopRight,\n} from '../extent.js';\nimport {clamp, squaredDistance, toFixed} from '../math.js';\nimport {createEditingStyle} from '../style/Style.js';\nimport {\n  distance,\n  squaredDistance as squaredCoordinateDistance,\n} from '../coordinate.js';\nimport {fromUserCoordinate, getUserProjection} from '../proj.js';\nimport {getStrideForLayout} from '../geom/SimpleGeometry.js';\n\n/**\n * @typedef {Object} Options\n * @property {import(\"../geom/Geometry.js\").Type} type Geometry type of\n * the geometries being drawn with this instance.\n * @property {number} [clickTolerance=6] The maximum distance in pixels between\n * \"down\" and \"up\" for a \"up\" event to be considered a \"click\" event and\n * actually add a point/vertex to the geometry being drawn.  The default of `6`\n * was chosen for the draw interaction to behave correctly on mouse as well as\n * on touch devices.\n * @property {import(\"../Collection.js\").default<Feature>} [features]\n * Destination collection for the drawn features.\n * @property {VectorSource} [source] Destination source for\n * the drawn features.\n * @property {number} [dragVertexDelay=500] Delay in milliseconds after pointerdown\n * before the current vertex can be dragged to its exact position.\n * @property {number} [snapTolerance=12] Pixel distance for snapping to the\n * drawing finish. Must be greater than `0`.\n * @property {boolean} [stopClick=false] Stop click, singleclick, and\n * doubleclick events from firing during drawing.\n * @property {number} [maxPoints] The number of points that can be drawn before\n * a polygon ring or line string is finished. By default there is no\n * restriction.\n * @property {number} [minPoints] The number of points that must be drawn\n * before a polygon ring or line string can be finished. Default is `3` for\n * polygon rings and `2` for line strings.\n * @property {import(\"../events/condition.js\").Condition} [finishCondition] A function\n * that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\n * boolean to indicate whether the drawing can be finished. Not used when drawing\n * POINT or MULTI_POINT geometries.\n * @property {import(\"../style/Style.js\").StyleLike|import(\"../style/flat.js\").FlatStyleLike} [style]\n * Style for sketch features.\n * @property {GeometryFunction} [geometryFunction]\n * Function that is called when a geometry's coordinates are updated.\n * @property {string} [geometryName] Geometry name to use for features created\n * by the draw interaction.\n * @property {import(\"../events/condition.js\").Condition} [condition] A function that\n * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\n * boolean to indicate whether that event should be handled.\n * By default {@link module:ol/events/condition.noModifierKeys}, i.e. a click,\n * adds a vertex or deactivates freehand drawing.\n * @property {boolean} [freehand=false] Operate in freehand mode for lines,\n * polygons, and circles.  This makes the interaction always operate in freehand\n * mode and takes precedence over any `freehandCondition` option.\n * @property {import(\"../events/condition.js\").Condition} [freehandCondition]\n * Condition that activates freehand drawing for lines and polygons. This\n * function takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and\n * returns a boolean to indicate whether that event should be handled. The\n * default is {@link module:ol/events/condition.shiftKeyOnly}, meaning that the\n * Shift key activates freehand drawing.\n * @property {boolean|import(\"../events/condition.js\").Condition} [trace=false] Trace a portion of another geometry.\n * Ignored when in freehand mode.\n * @property {VectorSource} [traceSource] Source for features to trace.  If tracing is active and a `traceSource` is\n * not provided, the interaction's `source` will be used.  Tracing requires that the interaction is configured with\n * either a `traceSource` or a `source`.\n * @property {boolean} [wrapX=false] Wrap the world horizontally on the sketch\n * overlay.\n * @property {import(\"../geom/Geometry.js\").GeometryLayout} [geometryLayout='XY'] Layout of the\n * feature geometries created by the draw interaction.\n */\n\n/**\n * Coordinate type when drawing points.\n * @typedef {import(\"../coordinate.js\").Coordinate} PointCoordType\n */\n\n/**\n * Coordinate type when drawing lines.\n * @typedef {Array<import(\"../coordinate.js\").Coordinate>} LineCoordType\n */\n\n/**\n * Coordinate type when drawing polygons.\n * @typedef {Array<Array<import(\"../coordinate.js\").Coordinate>>} PolyCoordType\n */\n\n/**\n * Types used for drawing coordinates.\n * @typedef {PointCoordType|LineCoordType|PolyCoordType} SketchCoordType\n */\n\n/**\n * @typedef {Object} TraceState\n * @property {boolean} active Tracing active.\n * @property {import(\"../pixel.js\").Pixel} [startPx] The initially clicked pixel location.\n * @property {Array<TraceTarget>} [targets] Targets available for tracing.\n * @property {number} [targetIndex] The index of the currently traced target.  A value of -1 indicates\n * that no trace target is active.\n */\n\n/**\n * @typedef {Object} TraceTarget\n * @property {Array<import(\"../coordinate.js\").Coordinate>} coordinates Target coordinates.\n * @property {boolean} ring The target coordinates are a linear ring.\n * @property {number} startIndex The index of first traced coordinate.  A fractional index represents an\n * edge intersection.  Index values for rings will wrap (may be negative or larger than coordinates length).\n * @property {number} endIndex The index of last traced coordinate.  Details from startIndex also apply here.\n */\n\n/**\n * Function that takes an array of coordinates and an optional existing geometry\n * and a projection as arguments, and returns a geometry. The optional existing\n * geometry is the geometry that is returned when the function is called without\n * a second argument.\n * @typedef {function(!SketchCoordType, import(\"../geom/SimpleGeometry.js\").default,\n *     import(\"../proj/Projection.js\").default):\n *     import(\"../geom/SimpleGeometry.js\").default} GeometryFunction\n */\n\n/**\n * @typedef {'Point' | 'LineString' | 'Polygon' | 'Circle'} Mode\n * Draw mode.  This collapses multi-part geometry types with their single-part\n * cousins.\n */\n\n/**\n * @enum {string}\n */\nconst DrawEventType = {\n  /**\n   * Triggered upon feature draw start\n   * @event DrawEvent#drawstart\n   * @api\n   */\n  DRAWSTART: 'drawstart',\n  /**\n   * Triggered upon feature draw end\n   * @event DrawEvent#drawend\n   * @api\n   */\n  DRAWEND: 'drawend',\n  /**\n   * Triggered upon feature draw abortion\n   * @event DrawEvent#drawabort\n   * @api\n   */\n  DRAWABORT: 'drawabort',\n};\n\n/**\n * @classdesc\n * Events emitted by {@link module:ol/interaction/Draw~Draw} instances are\n * instances of this type.\n */\nexport class DrawEvent extends Event {\n  /**\n   * @param {DrawEventType} type Type.\n   * @param {Feature} feature The feature drawn.\n   */\n  constructor(type, feature) {\n    super(type);\n\n    /**\n     * The feature being drawn.\n     * @type {Feature}\n     * @api\n     */\n    this.feature = feature;\n  }\n}\n\n/**\n * @param {import(\"../coordinate.js\").Coordinate} coordinate The coordinate.\n * @param {Array<Feature>} features The candidate features.\n * @return {Array<TraceTarget>} The trace targets.\n */\nfunction getTraceTargets(coordinate, features) {\n  /**\n   * @type {Array<TraceTarget>}\n   */\n  const targets = [];\n\n  for (let i = 0; i < features.length; ++i) {\n    const feature = features[i];\n    const geometry = feature.getGeometry();\n    appendGeometryTraceTargets(coordinate, geometry, targets);\n  }\n\n  return targets;\n}\n\n/**\n * @param {import(\"../coordinate.js\").Coordinate} a One coordinate.\n * @param {import(\"../coordinate.js\").Coordinate} b Another coordinate.\n * @return {number} The squared distance between the two coordinates.\n */\nfunction getSquaredDistance(a, b) {\n  return squaredDistance(a[0], a[1], b[0], b[1]);\n}\n\n/**\n * @param {LineCoordType} coordinates The ring coordinates.\n * @param {number} index The index.  May be wrapped.\n * @return {import(\"../coordinate.js\").Coordinate} The coordinate.\n */\nfunction getCoordinate(coordinates, index) {\n  const count = coordinates.length;\n  if (index < 0) {\n    return coordinates[index + count];\n  }\n  if (index >= count) {\n    return coordinates[index - count];\n  }\n  return coordinates[index];\n}\n\n/**\n * Get the cumulative squared distance along a ring path.  The end index index may be \"wrapped\" and it may\n * be less than the start index to indicate the direction of travel.  The start and end index may have\n * a fractional part to indicate a point between two coordinates.\n * @param {LineCoordType} coordinates Ring coordinates.\n * @param {number} startIndex The start index.\n * @param {number} endIndex The end index.\n * @return {number} The cumulative squared distance along the ring path.\n */\nfunction getCumulativeSquaredDistance(coordinates, startIndex, endIndex) {\n  let lowIndex, highIndex;\n  if (startIndex < endIndex) {\n    lowIndex = startIndex;\n    highIndex = endIndex;\n  } else {\n    lowIndex = endIndex;\n    highIndex = startIndex;\n  }\n  const lowWholeIndex = Math.ceil(lowIndex);\n  const highWholeIndex = Math.floor(highIndex);\n\n  if (lowWholeIndex > highWholeIndex) {\n    // both start and end are on the same segment\n    const start = interpolateCoordinate(coordinates, lowIndex);\n    const end = interpolateCoordinate(coordinates, highIndex);\n    return getSquaredDistance(start, end);\n  }\n\n  let sd = 0;\n\n  if (lowIndex < lowWholeIndex) {\n    const start = interpolateCoordinate(coordinates, lowIndex);\n    const end = getCoordinate(coordinates, lowWholeIndex);\n    sd += getSquaredDistance(start, end);\n  }\n\n  if (highWholeIndex < highIndex) {\n    const start = getCoordinate(coordinates, highWholeIndex);\n    const end = interpolateCoordinate(coordinates, highIndex);\n    sd += getSquaredDistance(start, end);\n  }\n\n  for (let i = lowWholeIndex; i < highWholeIndex - 1; ++i) {\n    const start = getCoordinate(coordinates, i);\n    const end = getCoordinate(coordinates, i + 1);\n    sd += getSquaredDistance(start, end);\n  }\n\n  return sd;\n}\n\n/**\n * @param {import(\"../coordinate.js\").Coordinate} coordinate The coordinate.\n * @param {import(\"../geom/Geometry.js\").default} geometry The candidate geometry.\n * @param {Array<TraceTarget>} targets The trace targets.\n */\nfunction appendGeometryTraceTargets(coordinate, geometry, targets) {\n  if (geometry instanceof LineString) {\n    appendTraceTarget(coordinate, geometry.getCoordinates(), false, targets);\n    return;\n  }\n  if (geometry instanceof MultiLineString) {\n    const coordinates = geometry.getCoordinates();\n    for (let i = 0, ii = coordinates.length; i < ii; ++i) {\n      appendTraceTarget(coordinate, coordinates[i], false, targets);\n    }\n    return;\n  }\n  if (geometry instanceof Polygon) {\n    const coordinates = geometry.getCoordinates();\n    for (let i = 0, ii = coordinates.length; i < ii; ++i) {\n      appendTraceTarget(coordinate, coordinates[i], true, targets);\n    }\n    return;\n  }\n  if (geometry instanceof MultiPolygon) {\n    const polys = geometry.getCoordinates();\n    for (let i = 0, ii = polys.length; i < ii; ++i) {\n      const coordinates = polys[i];\n      for (let j = 0, jj = coordinates.length; j < jj; ++j) {\n        appendTraceTarget(coordinate, coordinates[j], true, targets);\n      }\n    }\n    return;\n  }\n  if (geometry instanceof GeometryCollection) {\n    const geometries = geometry.getGeometries();\n    for (let i = 0; i < geometries.length; ++i) {\n      appendGeometryTraceTargets(coordinate, geometries[i], targets);\n    }\n    return;\n  }\n  // other types cannot be traced\n}\n\n/**\n * @typedef {Object} TraceTargetUpdateInfo\n * @property {number} index The new target index.\n * @property {number} endIndex The new segment end index.\n */\n\n/**\n * @type {TraceTargetUpdateInfo}\n */\nconst sharedUpdateInfo = {index: -1, endIndex: NaN};\n\n/**\n * @param {import(\"../coordinate.js\").Coordinate} coordinate The coordinate.\n * @param {TraceState} traceState The trace state.\n * @param {import(\"../Map.js\").default} map The map.\n * @param {number} snapTolerance The snap tolerance.\n * @return {TraceTargetUpdateInfo} Information about the new trace target.  The returned\n * object is reused between calls and must not be modified by the caller.\n */\nfunction getTraceTargetUpdate(coordinate, traceState, map, snapTolerance) {\n  const x = coordinate[0];\n  const y = coordinate[1];\n\n  let closestTargetDistance = Infinity;\n\n  let newTargetIndex = -1;\n  let newEndIndex = NaN;\n\n  for (\n    let targetIndex = 0;\n    targetIndex < traceState.targets.length;\n    ++targetIndex\n  ) {\n    const target = traceState.targets[targetIndex];\n    const coordinates = target.coordinates;\n\n    let minSegmentDistance = Infinity;\n    let endIndex;\n    for (\n      let coordinateIndex = 0;\n      coordinateIndex < coordinates.length - 1;\n      ++coordinateIndex\n    ) {\n      const start = coordinates[coordinateIndex];\n      const end = coordinates[coordinateIndex + 1];\n      const rel = getPointSegmentRelationship(x, y, start, end);\n      if (rel.squaredDistance < minSegmentDistance) {\n        minSegmentDistance = rel.squaredDistance;\n        endIndex = coordinateIndex + rel.along;\n      }\n    }\n\n    if (minSegmentDistance < closestTargetDistance) {\n      closestTargetDistance = minSegmentDistance;\n      if (target.ring && traceState.targetIndex === targetIndex) {\n        // same target, maintain the same trace direction\n        if (target.endIndex > target.startIndex) {\n          // forward trace\n          if (endIndex < target.startIndex) {\n            endIndex += coordinates.length;\n          }\n        } else if (target.endIndex < target.startIndex) {\n          // reverse trace\n          if (endIndex > target.startIndex) {\n            endIndex -= coordinates.length;\n          }\n        }\n      }\n      newEndIndex = endIndex;\n      newTargetIndex = targetIndex;\n    }\n  }\n\n  const newTarget = traceState.targets[newTargetIndex];\n  let considerBothDirections = newTarget.ring;\n  if (traceState.targetIndex === newTargetIndex && considerBothDirections) {\n    // only consider switching trace direction if close to the start\n    const newCoordinate = interpolateCoordinate(\n      newTarget.coordinates,\n      newEndIndex\n    );\n    const pixel = map.getPixelFromCoordinate(newCoordinate);\n    if (distance(pixel, traceState.startPx) > snapTolerance) {\n      considerBothDirections = false;\n    }\n  }\n\n  if (considerBothDirections) {\n    const coordinates = newTarget.coordinates;\n    const count = coordinates.length;\n    const startIndex = newTarget.startIndex;\n    const endIndex = newEndIndex;\n    if (startIndex < endIndex) {\n      const forwardDistance = getCumulativeSquaredDistance(\n        coordinates,\n        startIndex,\n        endIndex\n      );\n      const reverseDistance = getCumulativeSquaredDistance(\n        coordinates,\n        startIndex,\n        endIndex - count\n      );\n      if (reverseDistance < forwardDistance) {\n        newEndIndex -= count;\n      }\n    } else {\n      const reverseDistance = getCumulativeSquaredDistance(\n        coordinates,\n        startIndex,\n        endIndex\n      );\n      const forwardDistance = getCumulativeSquaredDistance(\n        coordinates,\n        startIndex,\n        endIndex + count\n      );\n      if (forwardDistance < reverseDistance) {\n        newEndIndex += count;\n      }\n    }\n  }\n\n  sharedUpdateInfo.index = newTargetIndex;\n  sharedUpdateInfo.endIndex = newEndIndex;\n  return sharedUpdateInfo;\n}\n\n/**\n * @param {import(\"../coordinate.js\").Coordinate} coordinate The clicked coordinate.\n * @param {Array<import(\"../coordinate.js\").Coordinate>} coordinates The geometry component coordinates.\n * @param {boolean} ring The coordinates represent a linear ring.\n * @param {Array<TraceTarget>} targets The trace targets.\n */\nfunction appendTraceTarget(coordinate, coordinates, ring, targets) {\n  const x = coordinate[0];\n  const y = coordinate[1];\n  for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n    const start = coordinates[i];\n    const end = coordinates[i + 1];\n    const rel = getPointSegmentRelationship(x, y, start, end);\n    if (rel.squaredDistance === 0) {\n      const index = i + rel.along;\n      targets.push({\n        coordinates: coordinates,\n        ring: ring,\n        startIndex: index,\n        endIndex: index,\n      });\n      return;\n    }\n  }\n}\n\n/**\n * @typedef {Object} PointSegmentRelationship\n * @property {number} along The closest point expressed as a fraction along the segment length.\n * @property {number} squaredDistance The squared distance of the point to the segment.\n */\n\n/**\n * @type {PointSegmentRelationship}\n */\nconst sharedRel = {along: 0, squaredDistance: 0};\n\n/**\n * @param {number} x The point x.\n * @param {number} y The point y.\n * @param {import(\"../coordinate.js\").Coordinate} start The segment start.\n * @param {import(\"../coordinate.js\").Coordinate} end The segment end.\n * @return {PointSegmentRelationship} The point segment relationship.  The returned object is\n * shared between calls and must not be modified by the caller.\n */\nfunction getPointSegmentRelationship(x, y, start, end) {\n  const x1 = start[0];\n  const y1 = start[1];\n  const x2 = end[0];\n  const y2 = end[1];\n  const dx = x2 - x1;\n  const dy = y2 - y1;\n  let along = 0;\n  let px = x1;\n  let py = y1;\n  if (dx !== 0 || dy !== 0) {\n    along = clamp(((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy), 0, 1);\n    px += dx * along;\n    py += dy * along;\n  }\n\n  sharedRel.along = along;\n  sharedRel.squaredDistance = toFixed(squaredDistance(x, y, px, py), 10);\n  return sharedRel;\n}\n\n/**\n * @param {LineCoordType} coordinates The coordinates.\n * @param {number} index The index.  May be fractional and may wrap.\n * @return {import(\"../coordinate.js\").Coordinate} The interpolated coordinate.\n */\nfunction interpolateCoordinate(coordinates, index) {\n  const count = coordinates.length;\n\n  let startIndex = Math.floor(index);\n  const along = index - startIndex;\n  if (startIndex >= count) {\n    startIndex -= count;\n  } else if (startIndex < 0) {\n    startIndex += count;\n  }\n\n  let endIndex = startIndex + 1;\n  if (endIndex >= count) {\n    endIndex -= count;\n  }\n\n  const start = coordinates[startIndex];\n  const x0 = start[0];\n  const y0 = start[1];\n  const end = coordinates[endIndex];\n  const dx = end[0] - x0;\n  const dy = end[1] - y0;\n\n  return [x0 + dx * along, y0 + dy * along];\n}\n\n/***\n * @template Return\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\n *   import(\"../Observable\").OnSignature<import(\"../ObjectEventType\").Types|\n *     'change:active', import(\"../Object\").ObjectEvent, Return> &\n *   import(\"../Observable\").OnSignature<'drawabort'|'drawend'|'drawstart', DrawEvent, Return> &\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"../ObjectEventType\").Types|\n *     'change:active'|'drawabort'|'drawend'|'drawstart', Return>} DrawOnSignature\n */\n\n/**\n * @classdesc\n * Interaction for drawing feature geometries.\n *\n * @fires DrawEvent\n * @api\n */\nclass Draw extends PointerInteraction {\n  /**\n   * @param {Options} options Options.\n   */\n  constructor(options) {\n    const pointerOptions = /** @type {import(\"./Pointer.js\").Options} */ (\n      options\n    );\n    if (!pointerOptions.stopDown) {\n      pointerOptions.stopDown = FALSE;\n    }\n\n    super(pointerOptions);\n\n    /***\n     * @type {DrawOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.on;\n\n    /***\n     * @type {DrawOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.once;\n\n    /***\n     * @type {DrawOnSignature<void>}\n     */\n    this.un;\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.shouldHandle_ = false;\n\n    /**\n     * @type {import(\"../pixel.js\").Pixel}\n     * @private\n     */\n    this.downPx_ = null;\n\n    /**\n     * @type {ReturnType<typeof setTimeout>}\n     * @private\n     */\n    this.downTimeout_;\n\n    /**\n     * @type {number|undefined}\n     * @private\n     */\n    this.lastDragTime_;\n\n    /**\n     * Pointer type of the last pointermove event\n     * @type {string}\n     * @private\n     */\n    this.pointerType_;\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.freehand_ = false;\n\n    /**\n     * Target source for drawn features.\n     * @type {VectorSource|null}\n     * @private\n     */\n    this.source_ = options.source ? options.source : null;\n\n    /**\n     * Target collection for drawn features.\n     * @type {import(\"../Collection.js\").default<Feature>|null}\n     * @private\n     */\n    this.features_ = options.features ? options.features : null;\n\n    /**\n     * Pixel distance for snapping.\n     * @type {number}\n     * @private\n     */\n    this.snapTolerance_ = options.snapTolerance ? options.snapTolerance : 12;\n\n    /**\n     * Geometry type.\n     * @type {import(\"../geom/Geometry.js\").Type}\n     * @private\n     */\n    this.type_ = /** @type {import(\"../geom/Geometry.js\").Type} */ (\n      options.type\n    );\n\n    /**\n     * Drawing mode (derived from geometry type.\n     * @type {Mode}\n     * @private\n     */\n    this.mode_ = getMode(this.type_);\n\n    /**\n     * Stop click, singleclick, and doubleclick events from firing during drawing.\n     * Default is `false`.\n     * @type {boolean}\n     * @private\n     */\n    this.stopClick_ = !!options.stopClick;\n\n    /**\n     * The number of points that must be drawn before a polygon ring or line\n     * string can be finished.  The default is 3 for polygon rings and 2 for\n     * line strings.\n     * @type {number}\n     * @private\n     */\n    this.minPoints_ = options.minPoints\n      ? options.minPoints\n      : this.mode_ === 'Polygon'\n      ? 3\n      : 2;\n\n    /**\n     * The number of points that can be drawn before a polygon ring or line string\n     * is finished. The default is no restriction.\n     * @type {number}\n     * @private\n     */\n    this.maxPoints_ =\n      this.mode_ === 'Circle'\n        ? 2\n        : options.maxPoints\n        ? options.maxPoints\n        : Infinity;\n\n    /**\n     * A function to decide if a potential finish coordinate is permissible\n     * @private\n     * @type {import(\"../events/condition.js\").Condition}\n     */\n    this.finishCondition_ = options.finishCondition\n      ? options.finishCondition\n      : TRUE;\n\n    /**\n     * @private\n     * @type {import(\"../geom/Geometry.js\").GeometryLayout}\n     */\n    this.geometryLayout_ = options.geometryLayout\n      ? options.geometryLayout\n      : 'XY';\n\n    let geometryFunction = options.geometryFunction;\n    if (!geometryFunction) {\n      const mode = this.mode_;\n      if (mode === 'Circle') {\n        /**\n         * @param {!LineCoordType} coordinates The coordinates.\n         * @param {import(\"../geom/SimpleGeometry.js\").default|undefined} geometry Optional geometry.\n         * @param {import(\"../proj/Projection.js\").default} projection The view projection.\n         * @return {import(\"../geom/SimpleGeometry.js\").default} A geometry.\n         */\n        geometryFunction = function (coordinates, geometry, projection) {\n          const circle = geometry\n            ? /** @type {Circle} */ (geometry)\n            : new Circle([NaN, NaN]);\n          const center = fromUserCoordinate(coordinates[0], projection);\n          const squaredLength = squaredCoordinateDistance(\n            center,\n            fromUserCoordinate(coordinates[coordinates.length - 1], projection)\n          );\n          circle.setCenterAndRadius(\n            center,\n            Math.sqrt(squaredLength),\n            this.geometryLayout_\n          );\n          const userProjection = getUserProjection();\n          if (userProjection) {\n            circle.transform(projection, userProjection);\n          }\n          return circle;\n        };\n      } else {\n        let Constructor;\n        if (mode === 'Point') {\n          Constructor = Point;\n        } else if (mode === 'LineString') {\n          Constructor = LineString;\n        } else if (mode === 'Polygon') {\n          Constructor = Polygon;\n        }\n        /**\n         * @param {!LineCoordType} coordinates The coordinates.\n         * @param {import(\"../geom/SimpleGeometry.js\").default|undefined} geometry Optional geometry.\n         * @param {import(\"../proj/Projection.js\").default} projection The view projection.\n         * @return {import(\"../geom/SimpleGeometry.js\").default} A geometry.\n         */\n        geometryFunction = function (coordinates, geometry, projection) {\n          if (geometry) {\n            if (mode === 'Polygon') {\n              if (coordinates[0].length) {\n                // Add a closing coordinate to match the first\n                geometry.setCoordinates(\n                  [coordinates[0].concat([coordinates[0][0]])],\n                  this.geometryLayout_\n                );\n              } else {\n                geometry.setCoordinates([], this.geometryLayout_);\n              }\n            } else {\n              geometry.setCoordinates(coordinates, this.geometryLayout_);\n            }\n          } else {\n            geometry = new Constructor(coordinates, this.geometryLayout_);\n          }\n          return geometry;\n        };\n      }\n    }\n\n    /**\n     * @type {GeometryFunction}\n     * @private\n     */\n    this.geometryFunction_ = geometryFunction;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.dragVertexDelay_ =\n      options.dragVertexDelay !== undefined ? options.dragVertexDelay : 500;\n\n    /**\n     * Finish coordinate for the feature (first point for polygons, last point for\n     * linestrings).\n     * @type {import(\"../coordinate.js\").Coordinate}\n     * @private\n     */\n    this.finishCoordinate_ = null;\n\n    /**\n     * Sketch feature.\n     * @type {Feature<import('../geom/SimpleGeometry.js').default>}\n     * @private\n     */\n    this.sketchFeature_ = null;\n\n    /**\n     * Sketch point.\n     * @type {Feature<Point>}\n     * @private\n     */\n    this.sketchPoint_ = null;\n\n    /**\n     * Sketch coordinates. Used when drawing a line or polygon.\n     * @type {SketchCoordType}\n     * @private\n     */\n    this.sketchCoords_ = null;\n\n    /**\n     * Sketch line. Used when drawing polygon.\n     * @type {Feature<LineString>}\n     * @private\n     */\n    this.sketchLine_ = null;\n\n    /**\n     * Sketch line coordinates. Used when drawing a polygon or circle.\n     * @type {LineCoordType}\n     * @private\n     */\n    this.sketchLineCoords_ = null;\n\n    /**\n     * Squared tolerance for handling up events.  If the squared distance\n     * between a down and up event is greater than this tolerance, up events\n     * will not be handled.\n     * @type {number}\n     * @private\n     */\n    this.squaredClickTolerance_ = options.clickTolerance\n      ? options.clickTolerance * options.clickTolerance\n      : 36;\n\n    /**\n     * Draw overlay where our sketch features are drawn.\n     * @type {VectorLayer}\n     * @private\n     */\n    this.overlay_ = new VectorLayer({\n      source: new VectorSource({\n        useSpatialIndex: false,\n        wrapX: options.wrapX ? options.wrapX : false,\n      }),\n      style: options.style ? options.style : getDefaultStyleFunction(),\n      updateWhileInteracting: true,\n    });\n\n    /**\n     * Name of the geometry attribute for newly created features.\n     * @type {string|undefined}\n     * @private\n     */\n    this.geometryName_ = options.geometryName;\n\n    /**\n     * @private\n     * @type {import(\"../events/condition.js\").Condition}\n     */\n    this.condition_ = options.condition ? options.condition : noModifierKeys;\n\n    /**\n     * @private\n     * @type {import(\"../events/condition.js\").Condition}\n     */\n    this.freehandCondition_;\n    if (options.freehand) {\n      this.freehandCondition_ = always;\n    } else {\n      this.freehandCondition_ = options.freehandCondition\n        ? options.freehandCondition\n        : shiftKeyOnly;\n    }\n\n    /**\n     * @type {import(\"../events/condition.js\").Condition}\n     * @private\n     */\n    this.traceCondition_;\n    this.setTrace(options.trace || false);\n\n    /**\n     * @type {TraceState}\n     * @private\n     */\n    this.traceState_ = {active: false};\n\n    /**\n     * @type {VectorSource|null}\n     * @private\n     */\n    this.traceSource_ = options.traceSource || options.source || null;\n\n    this.addChangeListener(InteractionProperty.ACTIVE, this.updateState_);\n  }\n\n  /**\n   * Toggle tracing mode or set a tracing condition.\n   *\n   * @param {boolean|import(\"../events/condition.js\").Condition} trace A boolean to toggle tracing mode or an event\n   *     condition that will be checked when a feature is clicked to determine if tracing should be active.\n   */\n  setTrace(trace) {\n    let condition;\n    if (!trace) {\n      condition = never;\n    } else if (trace === true) {\n      condition = always;\n    } else {\n      condition = trace;\n    }\n    this.traceCondition_ = condition;\n  }\n\n  /**\n   * Remove the interaction from its current map and attach it to the new map.\n   * Subclasses may set up event handlers to get notified about changes to\n   * the map here.\n   * @param {import(\"../Map.js\").default} map Map.\n   */\n  setMap(map) {\n    super.setMap(map);\n    this.updateState_();\n  }\n\n  /**\n   * Get the overlay layer that this interaction renders sketch features to.\n   * @return {VectorLayer} Overlay layer.\n   * @api\n   */\n  getOverlay() {\n    return this.overlay_;\n  }\n\n  /**\n   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} and may actually draw or finish the drawing.\n   * @param {import(\"../MapBrowserEvent.js\").default} event Map browser event.\n   * @return {boolean} `false` to stop event propagation.\n   * @api\n   */\n  handleEvent(event) {\n    if (event.originalEvent.type === EventType.CONTEXTMENU) {\n      // Avoid context menu for long taps when drawing on mobile\n      event.originalEvent.preventDefault();\n    }\n    this.freehand_ = this.mode_ !== 'Point' && this.freehandCondition_(event);\n    let move = event.type === MapBrowserEventType.POINTERMOVE;\n    let pass = true;\n    if (\n      !this.freehand_ &&\n      this.lastDragTime_ &&\n      event.type === MapBrowserEventType.POINTERDRAG\n    ) {\n      const now = Date.now();\n      if (now - this.lastDragTime_ >= this.dragVertexDelay_) {\n        this.downPx_ = event.pixel;\n        this.shouldHandle_ = !this.freehand_;\n        move = true;\n      } else {\n        this.lastDragTime_ = undefined;\n      }\n      if (this.shouldHandle_ && this.downTimeout_ !== undefined) {\n        clearTimeout(this.downTimeout_);\n        this.downTimeout_ = undefined;\n      }\n    }\n    if (\n      this.freehand_ &&\n      event.type === MapBrowserEventType.POINTERDRAG &&\n      this.sketchFeature_ !== null\n    ) {\n      this.addToDrawing_(event.coordinate);\n      pass = false;\n    } else if (\n      this.freehand_ &&\n      event.type === MapBrowserEventType.POINTERDOWN\n    ) {\n      pass = false;\n    } else if (move && this.getPointerCount() < 2) {\n      pass = event.type === MapBrowserEventType.POINTERMOVE;\n      if (pass && this.freehand_) {\n        this.handlePointerMove_(event);\n        if (this.shouldHandle_) {\n          // Avoid page scrolling when freehand drawing on mobile\n          event.originalEvent.preventDefault();\n        }\n      } else if (\n        event.originalEvent.pointerType === 'mouse' ||\n        (event.type === MapBrowserEventType.POINTERDRAG &&\n          this.downTimeout_ === undefined)\n      ) {\n        this.handlePointerMove_(event);\n      }\n    } else if (event.type === MapBrowserEventType.DBLCLICK) {\n      pass = false;\n    }\n\n    return super.handleEvent(event) && pass;\n  }\n\n  /**\n   * Handle pointer down events.\n   * @param {import(\"../MapBrowserEvent.js\").default} event Event.\n   * @return {boolean} If the event was consumed.\n   */\n  handleDownEvent(event) {\n    this.shouldHandle_ = !this.freehand_;\n\n    if (this.freehand_) {\n      this.downPx_ = event.pixel;\n      if (!this.finishCoordinate_) {\n        this.startDrawing_(event.coordinate);\n      }\n      return true;\n    }\n\n    if (!this.condition_(event)) {\n      this.lastDragTime_ = undefined;\n      return false;\n    }\n\n    this.lastDragTime_ = Date.now();\n    this.downTimeout_ = setTimeout(() => {\n      this.handlePointerMove_(\n        new MapBrowserEvent(\n          MapBrowserEventType.POINTERMOVE,\n          event.map,\n          event.originalEvent,\n          false,\n          event.frameState\n        )\n      );\n    }, this.dragVertexDelay_);\n    this.downPx_ = event.pixel;\n    return true;\n  }\n\n  /**\n   * @private\n   */\n  deactivateTrace_() {\n    this.traceState_ = {active: false};\n  }\n\n  /**\n   * Activate or deactivate trace state based on a browser event.\n   * @param {import(\"../MapBrowserEvent.js\").default} event Event.\n   * @private\n   */\n  toggleTraceState_(event) {\n    if (!this.traceSource_ || !this.traceCondition_(event)) {\n      return;\n    }\n\n    if (this.traceState_.active) {\n      this.deactivateTrace_();\n      return;\n    }\n\n    const map = this.getMap();\n    const lowerLeft = map.getCoordinateFromPixel([\n      event.pixel[0] - this.snapTolerance_,\n      event.pixel[1] + this.snapTolerance_,\n    ]);\n    const upperRight = map.getCoordinateFromPixel([\n      event.pixel[0] + this.snapTolerance_,\n      event.pixel[1] - this.snapTolerance_,\n    ]);\n    const extent = boundingExtent([lowerLeft, upperRight]);\n    const features = this.traceSource_.getFeaturesInExtent(extent);\n    if (features.length === 0) {\n      return;\n    }\n\n    const targets = getTraceTargets(event.coordinate, features);\n    if (targets.length) {\n      this.traceState_ = {\n        active: true,\n        startPx: event.pixel.slice(),\n        targets: targets,\n        targetIndex: -1,\n      };\n    }\n  }\n\n  /**\n   * @param {TraceTarget} target The trace target.\n   * @param {number} endIndex The new end index of the trace.\n   * @private\n   */\n  addOrRemoveTracedCoordinates_(target, endIndex) {\n    // three cases to handle:\n    //  1. traced in the same direction and points need adding\n    //  2. traced in the same direction and points need removing\n    //  3. traced in a new direction\n    const previouslyForward = target.startIndex <= target.endIndex;\n    const currentlyForward = target.startIndex <= endIndex;\n    if (previouslyForward === currentlyForward) {\n      // same direction\n      if (\n        (previouslyForward && endIndex > target.endIndex) ||\n        (!previouslyForward && endIndex < target.endIndex)\n      ) {\n        // case 1 - add new points\n        this.addTracedCoordinates_(target, target.endIndex, endIndex);\n      } else if (\n        (previouslyForward && endIndex < target.endIndex) ||\n        (!previouslyForward && endIndex > target.endIndex)\n      ) {\n        // case 2 - remove old points\n        this.removeTracedCoordinates_(endIndex, target.endIndex);\n      }\n    } else {\n      // case 3 - remove old points, add new points\n      this.removeTracedCoordinates_(target.startIndex, target.endIndex);\n      this.addTracedCoordinates_(target, target.startIndex, endIndex);\n    }\n  }\n\n  /**\n   * @param {number} fromIndex The start index.\n   * @param {number} toIndex The end index.\n   * @private\n   */\n  removeTracedCoordinates_(fromIndex, toIndex) {\n    if (fromIndex === toIndex) {\n      return;\n    }\n\n    let remove = 0;\n    if (fromIndex < toIndex) {\n      const start = Math.ceil(fromIndex);\n      let end = Math.floor(toIndex);\n      if (end === toIndex) {\n        end -= 1;\n      }\n      remove = end - start + 1;\n    } else {\n      const start = Math.floor(fromIndex);\n      let end = Math.ceil(toIndex);\n      if (end === toIndex) {\n        end += 1;\n      }\n      remove = start - end + 1;\n    }\n\n    if (remove > 0) {\n      this.removeLastPoints_(remove);\n    }\n  }\n\n  /**\n   * @param {TraceTarget} target The trace target.\n   * @param {number} fromIndex The start index.\n   * @param {number} toIndex The end index.\n   * @private\n   */\n  addTracedCoordinates_(target, fromIndex, toIndex) {\n    if (fromIndex === toIndex) {\n      return;\n    }\n\n    const coordinates = [];\n    if (fromIndex < toIndex) {\n      // forward trace\n      const start = Math.ceil(fromIndex);\n      let end = Math.floor(toIndex);\n      if (end === toIndex) {\n        // if end is snapped to a vertex, it will be added later\n        end -= 1;\n      }\n      for (let i = start; i <= end; ++i) {\n        coordinates.push(getCoordinate(target.coordinates, i));\n      }\n    } else {\n      // reverse trace\n      const start = Math.floor(fromIndex);\n      let end = Math.ceil(toIndex);\n      if (end === toIndex) {\n        end += 1;\n      }\n      for (let i = start; i >= end; --i) {\n        coordinates.push(getCoordinate(target.coordinates, i));\n      }\n    }\n    if (coordinates.length) {\n      this.appendCoordinates(coordinates);\n    }\n  }\n\n  /**\n   * Update the trace.\n   * @param {import(\"../MapBrowserEvent.js\").default} event Event.\n   * @private\n   */\n  updateTrace_(event) {\n    const traceState = this.traceState_;\n    if (!traceState.active) {\n      return;\n    }\n\n    if (traceState.targetIndex === -1) {\n      // check if we are ready to pick a target\n      if (distance(traceState.startPx, event.pixel) < this.snapTolerance_) {\n        return;\n      }\n    }\n\n    const updatedTraceTarget = getTraceTargetUpdate(\n      event.coordinate,\n      traceState,\n      this.getMap(),\n      this.snapTolerance_\n    );\n\n    if (traceState.targetIndex !== updatedTraceTarget.index) {\n      // target changed\n      if (traceState.targetIndex !== -1) {\n        // remove points added during previous trace\n        const oldTarget = traceState.targets[traceState.targetIndex];\n        this.removeTracedCoordinates_(oldTarget.startIndex, oldTarget.endIndex);\n      }\n      // add points for the new target\n      const newTarget = traceState.targets[updatedTraceTarget.index];\n      this.addTracedCoordinates_(\n        newTarget,\n        newTarget.startIndex,\n        updatedTraceTarget.endIndex\n      );\n    } else {\n      // target stayed the same\n      const target = traceState.targets[traceState.targetIndex];\n      this.addOrRemoveTracedCoordinates_(target, updatedTraceTarget.endIndex);\n    }\n\n    // modify the state with updated info\n    traceState.targetIndex = updatedTraceTarget.index;\n    const target = traceState.targets[traceState.targetIndex];\n    target.endIndex = updatedTraceTarget.endIndex;\n\n    // update event coordinate and pixel to match end point of final segment\n    const coordinate = interpolateCoordinate(\n      target.coordinates,\n      target.endIndex\n    );\n    const pixel = this.getMap().getPixelFromCoordinate(coordinate);\n    event.coordinate = coordinate;\n    event.pixel = [Math.round(pixel[0]), Math.round(pixel[1])];\n  }\n\n  /**\n   * Handle pointer up events.\n   * @param {import(\"../MapBrowserEvent.js\").default} event Event.\n   * @return {boolean} If the event was consumed.\n   */\n  handleUpEvent(event) {\n    let pass = true;\n\n    if (this.getPointerCount() === 0) {\n      if (this.downTimeout_) {\n        clearTimeout(this.downTimeout_);\n        this.downTimeout_ = undefined;\n      }\n\n      this.handlePointerMove_(event);\n      const tracing = this.traceState_.active;\n      this.toggleTraceState_(event);\n\n      if (this.shouldHandle_) {\n        const startingToDraw = !this.finishCoordinate_;\n        if (startingToDraw) {\n          this.startDrawing_(event.coordinate);\n        }\n        if (!startingToDraw && this.freehand_) {\n          this.finishDrawing();\n        } else if (\n          !this.freehand_ &&\n          (!startingToDraw || this.mode_ === 'Point')\n        ) {\n          if (this.atFinish_(event.pixel, tracing)) {\n            if (this.finishCondition_(event)) {\n              this.finishDrawing();\n            }\n          } else {\n            this.addToDrawing_(event.coordinate);\n          }\n        }\n        pass = false;\n      } else if (this.freehand_) {\n        this.abortDrawing();\n      }\n    }\n\n    if (!pass && this.stopClick_) {\n      event.preventDefault();\n    }\n    return pass;\n  }\n\n  /**\n   * Handle move events.\n   * @param {import(\"../MapBrowserEvent.js\").default} event A move event.\n   * @private\n   */\n  handlePointerMove_(event) {\n    this.pointerType_ = event.originalEvent.pointerType;\n    if (\n      this.downPx_ &&\n      ((!this.freehand_ && this.shouldHandle_) ||\n        (this.freehand_ && !this.shouldHandle_))\n    ) {\n      const downPx = this.downPx_;\n      const clickPx = event.pixel;\n      const dx = downPx[0] - clickPx[0];\n      const dy = downPx[1] - clickPx[1];\n      const squaredDistance = dx * dx + dy * dy;\n      this.shouldHandle_ = this.freehand_\n        ? squaredDistance > this.squaredClickTolerance_\n        : squaredDistance <= this.squaredClickTolerance_;\n      if (!this.shouldHandle_) {\n        return;\n      }\n    }\n\n    if (!this.finishCoordinate_) {\n      this.createOrUpdateSketchPoint_(event.coordinate.slice());\n      return;\n    }\n\n    this.updateTrace_(event);\n    this.modifyDrawing_(event.coordinate);\n  }\n\n  /**\n   * Determine if an event is within the snapping tolerance of the start coord.\n   * @param {import(\"../pixel.js\").Pixel} pixel Pixel.\n   * @param {boolean} [tracing] Drawing in trace mode (only stop if at the starting point).\n   * @return {boolean} The event is within the snapping tolerance of the start.\n   * @private\n   */\n  atFinish_(pixel, tracing) {\n    let at = false;\n    if (this.sketchFeature_) {\n      let potentiallyDone = false;\n      let potentiallyFinishCoordinates = [this.finishCoordinate_];\n      const mode = this.mode_;\n      if (mode === 'Point') {\n        at = true;\n      } else if (mode === 'Circle') {\n        at = this.sketchCoords_.length === 2;\n      } else if (mode === 'LineString') {\n        potentiallyDone =\n          !tracing && this.sketchCoords_.length > this.minPoints_;\n      } else if (mode === 'Polygon') {\n        const sketchCoords = /** @type {PolyCoordType} */ (this.sketchCoords_);\n        potentiallyDone = sketchCoords[0].length > this.minPoints_;\n        potentiallyFinishCoordinates = [\n          sketchCoords[0][0],\n          sketchCoords[0][sketchCoords[0].length - 2],\n        ];\n        if (tracing) {\n          potentiallyFinishCoordinates = [sketchCoords[0][0]];\n        } else {\n          potentiallyFinishCoordinates = [\n            sketchCoords[0][0],\n            sketchCoords[0][sketchCoords[0].length - 2],\n          ];\n        }\n      }\n      if (potentiallyDone) {\n        const map = this.getMap();\n        for (let i = 0, ii = potentiallyFinishCoordinates.length; i < ii; i++) {\n          const finishCoordinate = potentiallyFinishCoordinates[i];\n          const finishPixel = map.getPixelFromCoordinate(finishCoordinate);\n          const dx = pixel[0] - finishPixel[0];\n          const dy = pixel[1] - finishPixel[1];\n          const snapTolerance = this.freehand_ ? 1 : this.snapTolerance_;\n          at = Math.sqrt(dx * dx + dy * dy) <= snapTolerance;\n          if (at) {\n            this.finishCoordinate_ = finishCoordinate;\n            break;\n          }\n        }\n      }\n    }\n    return at;\n  }\n\n  /**\n   * @param {import(\"../coordinate\").Coordinate} coordinates Coordinate.\n   * @private\n   */\n  createOrUpdateSketchPoint_(coordinates) {\n    if (!this.sketchPoint_) {\n      this.sketchPoint_ = new Feature(new Point(coordinates));\n      this.updateSketchFeatures_();\n    } else {\n      const sketchPointGeom = this.sketchPoint_.getGeometry();\n      sketchPointGeom.setCoordinates(coordinates);\n    }\n  }\n\n  /**\n   * @param {import(\"../geom/Polygon.js\").default} geometry Polygon geometry.\n   * @private\n   */\n  createOrUpdateCustomSketchLine_(geometry) {\n    if (!this.sketchLine_) {\n      this.sketchLine_ = new Feature();\n    }\n    const ring = geometry.getLinearRing(0);\n    let sketchLineGeom = this.sketchLine_.getGeometry();\n    if (!sketchLineGeom) {\n      sketchLineGeom = new LineString(\n        ring.getFlatCoordinates(),\n        ring.getLayout()\n      );\n      this.sketchLine_.setGeometry(sketchLineGeom);\n    } else {\n      sketchLineGeom.setFlatCoordinates(\n        ring.getLayout(),\n        ring.getFlatCoordinates()\n      );\n      sketchLineGeom.changed();\n    }\n  }\n\n  /**\n   * Start the drawing.\n   * @param {import(\"../coordinate.js\").Coordinate} start Start coordinate.\n   * @private\n   */\n  startDrawing_(start) {\n    const projection = this.getMap().getView().getProjection();\n    const stride = getStrideForLayout(this.geometryLayout_);\n    while (start.length < stride) {\n      start.push(0);\n    }\n    this.finishCoordinate_ = start;\n    if (this.mode_ === 'Point') {\n      this.sketchCoords_ = start.slice();\n    } else if (this.mode_ === 'Polygon') {\n      this.sketchCoords_ = [[start.slice(), start.slice()]];\n      this.sketchLineCoords_ = this.sketchCoords_[0];\n    } else {\n      this.sketchCoords_ = [start.slice(), start.slice()];\n    }\n    if (this.sketchLineCoords_) {\n      this.sketchLine_ = new Feature(new LineString(this.sketchLineCoords_));\n    }\n    const geometry = this.geometryFunction_(\n      this.sketchCoords_,\n      undefined,\n      projection\n    );\n    this.sketchFeature_ = new Feature();\n    if (this.geometryName_) {\n      this.sketchFeature_.setGeometryName(this.geometryName_);\n    }\n    this.sketchFeature_.setGeometry(geometry);\n    this.updateSketchFeatures_();\n    this.dispatchEvent(\n      new DrawEvent(DrawEventType.DRAWSTART, this.sketchFeature_)\n    );\n  }\n\n  /**\n   * Modify the drawing.\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @private\n   */\n  modifyDrawing_(coordinate) {\n    const map = this.getMap();\n    const geometry = this.sketchFeature_.getGeometry();\n    const projection = map.getView().getProjection();\n    const stride = getStrideForLayout(this.geometryLayout_);\n    let coordinates, last;\n    while (coordinate.length < stride) {\n      coordinate.push(0);\n    }\n    if (this.mode_ === 'Point') {\n      last = this.sketchCoords_;\n    } else if (this.mode_ === 'Polygon') {\n      coordinates = /** @type {PolyCoordType} */ (this.sketchCoords_)[0];\n      last = coordinates[coordinates.length - 1];\n      if (this.atFinish_(map.getPixelFromCoordinate(coordinate))) {\n        // snap to finish\n        coordinate = this.finishCoordinate_.slice();\n      }\n    } else {\n      coordinates = this.sketchCoords_;\n      last = coordinates[coordinates.length - 1];\n    }\n    last[0] = coordinate[0];\n    last[1] = coordinate[1];\n    this.geometryFunction_(\n      /** @type {!LineCoordType} */ (this.sketchCoords_),\n      geometry,\n      projection\n    );\n    if (this.sketchPoint_) {\n      const sketchPointGeom = this.sketchPoint_.getGeometry();\n      sketchPointGeom.setCoordinates(coordinate);\n    }\n    if (geometry.getType() === 'Polygon' && this.mode_ !== 'Polygon') {\n      this.createOrUpdateCustomSketchLine_(/** @type {Polygon} */ (geometry));\n    } else if (this.sketchLineCoords_) {\n      const sketchLineGeom = this.sketchLine_.getGeometry();\n      sketchLineGeom.setCoordinates(this.sketchLineCoords_);\n    }\n    this.updateSketchFeatures_();\n  }\n\n  /**\n   * Add a new coordinate to the drawing.\n   * @param {!PointCoordType} coordinate Coordinate\n   * @private\n   */\n  addToDrawing_(coordinate) {\n    const geometry = this.sketchFeature_.getGeometry();\n    const projection = this.getMap().getView().getProjection();\n    let done;\n    let coordinates;\n    const mode = this.mode_;\n    if (mode === 'LineString' || mode === 'Circle') {\n      this.finishCoordinate_ = coordinate.slice();\n      coordinates = /** @type {LineCoordType} */ (this.sketchCoords_);\n      if (coordinates.length >= this.maxPoints_) {\n        if (this.freehand_) {\n          coordinates.pop();\n        } else {\n          done = true;\n        }\n      }\n      coordinates.push(coordinate.slice());\n      this.geometryFunction_(coordinates, geometry, projection);\n    } else if (mode === 'Polygon') {\n      coordinates = /** @type {PolyCoordType} */ (this.sketchCoords_)[0];\n      if (coordinates.length >= this.maxPoints_) {\n        if (this.freehand_) {\n          coordinates.pop();\n        } else {\n          done = true;\n        }\n      }\n      coordinates.push(coordinate.slice());\n      if (done) {\n        this.finishCoordinate_ = coordinates[0];\n      }\n      this.geometryFunction_(this.sketchCoords_, geometry, projection);\n    }\n    this.createOrUpdateSketchPoint_(coordinate.slice());\n    this.updateSketchFeatures_();\n    if (done) {\n      this.finishDrawing();\n    }\n  }\n\n  /**\n   * @param {number} n The number of points to remove.\n   */\n  removeLastPoints_(n) {\n    if (!this.sketchFeature_) {\n      return;\n    }\n    const geometry = this.sketchFeature_.getGeometry();\n    const projection = this.getMap().getView().getProjection();\n    const mode = this.mode_;\n    for (let i = 0; i < n; ++i) {\n      let coordinates;\n      if (mode === 'LineString' || mode === 'Circle') {\n        coordinates = /** @type {LineCoordType} */ (this.sketchCoords_);\n        coordinates.splice(-2, 1);\n        if (coordinates.length >= 2) {\n          this.finishCoordinate_ = coordinates[coordinates.length - 2].slice();\n          const finishCoordinate = this.finishCoordinate_.slice();\n          coordinates[coordinates.length - 1] = finishCoordinate;\n          this.createOrUpdateSketchPoint_(finishCoordinate);\n        }\n        this.geometryFunction_(coordinates, geometry, projection);\n        if (geometry.getType() === 'Polygon' && this.sketchLine_) {\n          this.createOrUpdateCustomSketchLine_(\n            /** @type {Polygon} */ (geometry)\n          );\n        }\n      } else if (mode === 'Polygon') {\n        coordinates = /** @type {PolyCoordType} */ (this.sketchCoords_)[0];\n        coordinates.splice(-2, 1);\n        const sketchLineGeom = this.sketchLine_.getGeometry();\n        if (coordinates.length >= 2) {\n          const finishCoordinate = coordinates[coordinates.length - 2].slice();\n          coordinates[coordinates.length - 1] = finishCoordinate;\n          this.createOrUpdateSketchPoint_(finishCoordinate);\n        }\n        sketchLineGeom.setCoordinates(coordinates);\n        this.geometryFunction_(this.sketchCoords_, geometry, projection);\n      }\n\n      if (coordinates.length === 1) {\n        this.abortDrawing();\n        break;\n      }\n    }\n\n    this.updateSketchFeatures_();\n  }\n\n  /**\n   * Remove last point of the feature currently being drawn. Does not do anything when\n   * drawing POINT or MULTI_POINT geometries.\n   * @api\n   */\n  removeLastPoint() {\n    this.removeLastPoints_(1);\n  }\n\n  /**\n   * Stop drawing and add the sketch feature to the target layer.\n   * The {@link module:ol/interaction/Draw~DrawEventType.DRAWEND} event is\n   * dispatched before inserting the feature.\n   * @api\n   */\n  finishDrawing() {\n    const sketchFeature = this.abortDrawing_();\n    if (!sketchFeature) {\n      return;\n    }\n    let coordinates = this.sketchCoords_;\n    const geometry = sketchFeature.getGeometry();\n    const projection = this.getMap().getView().getProjection();\n    if (this.mode_ === 'LineString') {\n      // remove the redundant last point\n      coordinates.pop();\n      this.geometryFunction_(coordinates, geometry, projection);\n    } else if (this.mode_ === 'Polygon') {\n      // remove the redundant last point in ring\n      /** @type {PolyCoordType} */ (coordinates)[0].pop();\n      this.geometryFunction_(coordinates, geometry, projection);\n      coordinates = geometry.getCoordinates();\n    }\n\n    // cast multi-part geometries\n    if (this.type_ === 'MultiPoint') {\n      sketchFeature.setGeometry(\n        new MultiPoint([/** @type {PointCoordType} */ (coordinates)])\n      );\n    } else if (this.type_ === 'MultiLineString') {\n      sketchFeature.setGeometry(\n        new MultiLineString([/** @type {LineCoordType} */ (coordinates)])\n      );\n    } else if (this.type_ === 'MultiPolygon') {\n      sketchFeature.setGeometry(\n        new MultiPolygon([/** @type {PolyCoordType} */ (coordinates)])\n      );\n    }\n\n    // First dispatch event to allow full set up of feature\n    this.dispatchEvent(new DrawEvent(DrawEventType.DRAWEND, sketchFeature));\n\n    // Then insert feature\n    if (this.features_) {\n      this.features_.push(sketchFeature);\n    }\n    if (this.source_) {\n      this.source_.addFeature(sketchFeature);\n    }\n  }\n\n  /**\n   * Stop drawing without adding the sketch feature to the target layer.\n   * @return {Feature<import(\"../geom/SimpleGeometry.js\").default>|null} The sketch feature (or null if none).\n   * @private\n   */\n  abortDrawing_() {\n    this.finishCoordinate_ = null;\n    const sketchFeature = this.sketchFeature_;\n    this.sketchFeature_ = null;\n    this.sketchPoint_ = null;\n    this.sketchLine_ = null;\n    this.overlay_.getSource().clear(true);\n    this.deactivateTrace_();\n    return sketchFeature;\n  }\n\n  /**\n   * Stop drawing without adding the sketch feature to the target layer.\n   * @api\n   */\n  abortDrawing() {\n    const sketchFeature = this.abortDrawing_();\n    if (sketchFeature) {\n      this.dispatchEvent(new DrawEvent(DrawEventType.DRAWABORT, sketchFeature));\n    }\n  }\n\n  /**\n   * Append coordinates to the end of the geometry that is currently being drawn.\n   * This can be used when drawing LineStrings or Polygons. Coordinates will\n   * either be appended to the current LineString or the outer ring of the current\n   * Polygon. If no geometry is being drawn, a new one will be created.\n   * @param {!LineCoordType} coordinates Linear coordinates to be appended to\n   * the coordinate array.\n   * @api\n   */\n  appendCoordinates(coordinates) {\n    const mode = this.mode_;\n    const newDrawing = !this.sketchFeature_;\n    if (newDrawing) {\n      this.startDrawing_(coordinates[0]);\n    }\n    /** @type {LineCoordType} */\n    let sketchCoords;\n    if (mode === 'LineString' || mode === 'Circle') {\n      sketchCoords = /** @type {LineCoordType} */ (this.sketchCoords_);\n    } else if (mode === 'Polygon') {\n      sketchCoords =\n        this.sketchCoords_ && this.sketchCoords_.length\n          ? /** @type {PolyCoordType} */ (this.sketchCoords_)[0]\n          : [];\n    } else {\n      return;\n    }\n\n    if (newDrawing) {\n      sketchCoords.shift();\n    }\n\n    // Remove last coordinate from sketch drawing (this coordinate follows cursor position)\n    sketchCoords.pop();\n\n    // Append coordinate list\n    for (let i = 0; i < coordinates.length; i++) {\n      this.addToDrawing_(coordinates[i]);\n    }\n\n    const ending = coordinates[coordinates.length - 1];\n    // Duplicate last coordinate for sketch drawing (cursor position)\n    this.addToDrawing_(ending);\n    this.modifyDrawing_(ending);\n  }\n\n  /**\n   * Initiate draw mode by starting from an existing geometry which will\n   * receive new additional points. This only works on features with\n   * `LineString` geometries, where the interaction will extend lines by adding\n   * points to the end of the coordinates array.\n   * This will change the original feature, instead of drawing a copy.\n   *\n   * The function will dispatch a `drawstart` event.\n   *\n   * @param {!Feature<LineString>} feature Feature to be extended.\n   * @api\n   */\n  extend(feature) {\n    const geometry = feature.getGeometry();\n    const lineString = geometry;\n    this.sketchFeature_ = feature;\n    this.sketchCoords_ = lineString.getCoordinates();\n    const last = this.sketchCoords_[this.sketchCoords_.length - 1];\n    this.finishCoordinate_ = last.slice();\n    this.sketchCoords_.push(last.slice());\n    this.sketchPoint_ = new Feature(new Point(last));\n    this.updateSketchFeatures_();\n    this.dispatchEvent(\n      new DrawEvent(DrawEventType.DRAWSTART, this.sketchFeature_)\n    );\n  }\n\n  /**\n   * Redraw the sketch features.\n   * @private\n   */\n  updateSketchFeatures_() {\n    const sketchFeatures = [];\n    if (this.sketchFeature_) {\n      sketchFeatures.push(this.sketchFeature_);\n    }\n    if (this.sketchLine_) {\n      sketchFeatures.push(this.sketchLine_);\n    }\n    if (this.sketchPoint_) {\n      sketchFeatures.push(this.sketchPoint_);\n    }\n    const overlaySource = this.overlay_.getSource();\n    overlaySource.clear(true);\n    overlaySource.addFeatures(sketchFeatures);\n  }\n\n  /**\n   * @private\n   */\n  updateState_() {\n    const map = this.getMap();\n    const active = this.getActive();\n    if (!map || !active) {\n      this.abortDrawing();\n    }\n    this.overlay_.setMap(active ? map : null);\n  }\n}\n\n/**\n * @return {import(\"../style/Style.js\").StyleFunction} Styles.\n */\nfunction getDefaultStyleFunction() {\n  const styles = createEditingStyle();\n  return function (feature, resolution) {\n    return styles[feature.getGeometry().getType()];\n  };\n}\n\n/**\n * Create a `geometryFunction` for `type: 'Circle'` that will create a regular\n * polygon with a user specified number of sides and start angle instead of a\n * {@link import(\"../geom/Circle.js\").Circle} geometry.\n * @param {number} [sides] Number of sides of the regular polygon.\n *     Default is 32.\n * @param {number} [angle] Angle of the first point in counter-clockwise\n *     radians. 0 means East.\n *     Default is the angle defined by the heading from the center of the\n *     regular polygon to the current pointer position.\n * @return {GeometryFunction} Function that draws a polygon.\n * @api\n */\nexport function createRegularPolygon(sides, angle) {\n  return function (coordinates, geometry, projection) {\n    const center = fromUserCoordinate(\n      /** @type {LineCoordType} */ (coordinates)[0],\n      projection\n    );\n    const end = fromUserCoordinate(\n      /** @type {LineCoordType} */ (coordinates)[coordinates.length - 1],\n      projection\n    );\n    const radius = Math.sqrt(squaredCoordinateDistance(center, end));\n    geometry = geometry || fromCircle(new Circle(center), sides);\n\n    let internalAngle = angle;\n    if (!angle && angle !== 0) {\n      const x = end[0] - center[0];\n      const y = end[1] - center[1];\n      internalAngle = Math.atan2(y, x);\n    }\n    makeRegular(\n      /** @type {Polygon} */ (geometry),\n      center,\n      radius,\n      internalAngle\n    );\n\n    const userProjection = getUserProjection();\n    if (userProjection) {\n      geometry.transform(projection, userProjection);\n    }\n    return geometry;\n  };\n}\n\n/**\n * Create a `geometryFunction` that will create a box-shaped polygon (aligned\n * with the coordinate system axes).  Use this with the draw interaction and\n * `type: 'Circle'` to return a box instead of a circle geometry.\n * @return {GeometryFunction} Function that draws a box-shaped polygon.\n * @api\n */\nexport function createBox() {\n  return function (coordinates, geometry, projection) {\n    const extent = boundingExtent(\n      /** @type {LineCoordType} */ ([\n        coordinates[0],\n        coordinates[coordinates.length - 1],\n      ]).map(function (coordinate) {\n        return fromUserCoordinate(coordinate, projection);\n      })\n    );\n    const boxCoordinates = [\n      [\n        getBottomLeft(extent),\n        getBottomRight(extent),\n        getTopRight(extent),\n        getTopLeft(extent),\n        getBottomLeft(extent),\n      ],\n    ];\n    if (geometry) {\n      geometry.setCoordinates(boxCoordinates);\n    } else {\n      geometry = new Polygon(boxCoordinates);\n    }\n    const userProjection = getUserProjection();\n    if (userProjection) {\n      geometry.transform(projection, userProjection);\n    }\n    return geometry;\n  };\n}\n\n/**\n * Get the drawing mode.  The mode for multi-part geometries is the same as for\n * their single-part cousins.\n * @param {import(\"../geom/Geometry.js\").Type} type Geometry type.\n * @return {Mode} Drawing mode.\n */\nfunction getMode(type) {\n  switch (type) {\n    case 'Point':\n    case 'MultiPoint':\n      return 'Point';\n    case 'LineString':\n    case 'MultiLineString':\n      return 'LineString';\n    case 'Polygon':\n    case 'MultiPolygon':\n      return 'Polygon';\n    case 'Circle':\n      return 'Circle';\n    default:\n      throw new Error('Invalid type: ' + type);\n  }\n}\n\nexport default Draw;\n","import Polygon from \"ol/geom/Polygon\";\nimport { Draw } from \"ol/interaction\";\nimport VectorLayer from \"ol/layer/Vector\";\nimport VectorSource, { VectorSourceEvent } from \"ol/source/Vector\";\nimport { useEffect, useRef } from \"react\";\nimport { useMap } from \"src/contexts/mapContext\";\n\ninterface DrawingLayerProps {\n  zIndex?: number;\n  strokeColor?: string;\n  fillcolor?: string;\n  strokeWidth?: number;\n  circleRadius?: number;\n  circleFillColor?: string;\n  onChange?: (boundary: Polygon) => void;\n}\n\nconst DrawingLayer = ({\n  zIndex = 2,\n  strokeColor = \"#ffcc33\",\n  fillcolor = \"rgba(255, 255, 255, 0.2)\",\n  strokeWidth = 2,\n  circleRadius = 7,\n  circleFillColor = \"#ffcc33\",\n  onChange,\n}: DrawingLayerProps) => {\n  const map = useMap();\n  const source = new VectorSource();\n  const vector = new VectorLayer({\n    source: source,\n    style: {\n      \"fill-color\": fillcolor,\n      \"stroke-color\": strokeColor,\n      \"stroke-width\": strokeWidth,\n      \"circle-radius\": circleRadius,\n      \"circle-fill-color\": circleFillColor,\n    },\n  });\n  const ref = useRef<HTMLDivElement>(null);\n\n  useEffect(() => {\n    if (!ref.current) {\n      return;\n    }\n\n    map.addInteraction(new Draw({ source: source, type: \"Polygon\" }));\n    vector.setZIndex(zIndex);\n    map.addLayer(vector);\n\n    source.on(\"addfeature\", async function (evt: VectorSourceEvent) {\n      let feature = evt.feature;\n      let geometry = feature?.getGeometry() as Polygon;\n      if (onChange) {\n        onChange(geometry);\n      }\n    });\n  }, [ref, zIndex]);\n\n  return <div ref={ref} />;\n};\n\nexport default DrawingLayer;\n"],"names":["VectorLayer","BaseVectorLayer","options","CanvasVectorLayerRenderer","VectorLayer$1","Circle","SimpleGeometry","center","radius","layout","circle","x","y","closestPoint","minSquaredDistance","flatCoordinates","dx","dy","squaredDistance","i","delta","extent","createOrUpdate","circleExtent","intersects","forEachCorner","stride","offset","deflateCoordinate","ii","coordinates","angle","anchor","rotate","Circle$1","DrawEventType","DrawEvent","Event","type","feature","getTraceTargets","coordinate","features","targets","geometry","appendGeometryTraceTargets","getSquaredDistance","a","b","getCoordinate","index","count","getCumulativeSquaredDistance","startIndex","endIndex","lowIndex","highIndex","lowWholeIndex","highWholeIndex","start","interpolateCoordinate","end","sd","LineString","appendTraceTarget","MultiLineString","Polygon","MultiPolygon","polys","j","jj","GeometryCollection","geometries","sharedUpdateInfo","getTraceTargetUpdate","traceState","map","snapTolerance","closestTargetDistance","newTargetIndex","newEndIndex","targetIndex","target","minSegmentDistance","coordinateIndex","rel","getPointSegmentRelationship","newTarget","considerBothDirections","newCoordinate","pixel","distance","forwardDistance","reverseDistance","ring","sharedRel","x1","y1","x2","y2","along","px","py","clamp","toFixed","x0","y0","Draw","PointerInteraction","pointerOptions","FALSE","getMode","TRUE","geometryFunction","mode","projection","fromUserCoordinate","squaredLength","squaredCoordinateDistance","userProjection","getUserProjection","Constructor","Point","VectorSource","getDefaultStyleFunction","noModifierKeys","always","shiftKeyOnly","InteractionProperty","trace","condition","never","event","EventType","move","MapBrowserEventType","pass","MapBrowserEvent","lowerLeft","upperRight","boundingExtent","previouslyForward","currentlyForward","fromIndex","toIndex","remove","updatedTraceTarget","oldTarget","tracing","startingToDraw","downPx","clickPx","at","potentiallyDone","potentiallyFinishCoordinates","sketchCoords","finishCoordinate","finishPixel","Feature","sketchLineGeom","getStrideForLayout","last","done","n","sketchFeature","MultiPoint","newDrawing","ending","lineString","sketchFeatures","overlaySource","active","styles","createEditingStyle","resolution","Draw$1","DrawingLayer","zIndex","strokeColor","fillcolor","strokeWidth","circleRadius","circleFillColor","onChange","useMap","source","vector","style","ref","useRef","useEffect","current","addInteraction","setZIndex","addLayer","on","evt","getGeometry","_jsx"],"mappings":"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","x_google_ignoreList":[0,1,2]}