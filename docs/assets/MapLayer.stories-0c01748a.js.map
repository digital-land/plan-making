{"version":3,"file":"MapLayer.stories-0c01748a.js","sources":["../../node_modules/ol/ImageBase.js","../../node_modules/ol/ImageCanvas.js","../../node_modules/ol/renderer/canvas/ImageLayer.js","../../node_modules/ol/format/JSONFeature.js","../../node_modules/ol/format/GeoJSON.js","../../node_modules/ol/renderer/canvas/VectorImageLayer.js","../../node_modules/ol/layer/VectorImage.js","../../src/components/maps/mapLayer.tsx"],"sourcesContent":["/**\n * @module ol/ImageBase\n */\nimport EventTarget from './events/Target.js';\nimport EventType from './events/EventType.js';\nimport {abstract} from './util.js';\n\n/**\n * @abstract\n */\nclass ImageBase extends EventTarget {\n  /**\n   * @param {import(\"./extent.js\").Extent} extent Extent.\n   * @param {number|undefined} resolution Resolution.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"./ImageState.js\").default} state State.\n   */\n  constructor(extent, resolution, pixelRatio, state) {\n    super();\n\n    /**\n     * @protected\n     * @type {import(\"./extent.js\").Extent}\n     */\n    this.extent = extent;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.pixelRatio_ = pixelRatio;\n\n    /**\n     * @protected\n     * @type {number|undefined}\n     */\n    this.resolution = resolution;\n\n    /**\n     * @protected\n     * @type {import(\"./ImageState.js\").default}\n     */\n    this.state = state;\n  }\n\n  /**\n   * @protected\n   */\n  changed() {\n    this.dispatchEvent(EventType.CHANGE);\n  }\n\n  /**\n   * @return {import(\"./extent.js\").Extent} Extent.\n   */\n  getExtent() {\n    return this.extent;\n  }\n\n  /**\n   * @abstract\n   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.\n   */\n  getImage() {\n    return abstract();\n  }\n\n  /**\n   * @return {number} PixelRatio.\n   */\n  getPixelRatio() {\n    return this.pixelRatio_;\n  }\n\n  /**\n   * @return {number} Resolution.\n   */\n  getResolution() {\n    return /** @type {number} */ (this.resolution);\n  }\n\n  /**\n   * @return {import(\"./ImageState.js\").default} State.\n   */\n  getState() {\n    return this.state;\n  }\n\n  /**\n   * Load not yet loaded URI.\n   * @abstract\n   */\n  load() {\n    abstract();\n  }\n}\n\nexport default ImageBase;\n","/**\n * @module ol/ImageCanvas\n */\nimport ImageBase from './ImageBase.js';\nimport ImageState from './ImageState.js';\n\n/**\n * A function that is called to trigger asynchronous canvas drawing.  It is\n * called with a \"done\" callback that should be called when drawing is done.\n * If any error occurs during drawing, the \"done\" callback should be called with\n * that error.\n *\n * @typedef {function(function(Error=): void): void} Loader\n */\n\nclass ImageCanvas extends ImageBase {\n  /**\n   * @param {import(\"./extent.js\").Extent} extent Extent.\n   * @param {number} resolution Resolution.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {HTMLCanvasElement} canvas Canvas.\n   * @param {Loader} [loader] Optional loader function to\n   *     support asynchronous canvas drawing.\n   */\n  constructor(extent, resolution, pixelRatio, canvas, loader) {\n    const state = loader !== undefined ? ImageState.IDLE : ImageState.LOADED;\n\n    super(extent, resolution, pixelRatio, state);\n\n    /**\n     * Optional canvas loader function.\n     * @type {?Loader}\n     * @private\n     */\n    this.loader_ = loader !== undefined ? loader : null;\n\n    /**\n     * @private\n     * @type {HTMLCanvasElement}\n     */\n    this.canvas_ = canvas;\n\n    /**\n     * @private\n     * @type {?Error}\n     */\n    this.error_ = null;\n  }\n\n  /**\n   * Get any error associated with asynchronous rendering.\n   * @return {?Error} Any error that occurred during rendering.\n   */\n  getError() {\n    return this.error_;\n  }\n\n  /**\n   * Handle async drawing complete.\n   * @param {Error} [err] Any error during drawing.\n   * @private\n   */\n  handleLoad_(err) {\n    if (err) {\n      this.error_ = err;\n      this.state = ImageState.ERROR;\n    } else {\n      this.state = ImageState.LOADED;\n    }\n    this.changed();\n  }\n\n  /**\n   * Load not yet loaded URI.\n   */\n  load() {\n    if (this.state == ImageState.IDLE) {\n      this.state = ImageState.LOADING;\n      this.changed();\n      this.loader_(this.handleLoad_.bind(this));\n    }\n  }\n\n  /**\n   * @return {HTMLCanvasElement} Canvas element.\n   */\n  getImage() {\n    return this.canvas_;\n  }\n}\n\nexport default ImageCanvas;\n","/**\n * @module ol/renderer/canvas/ImageLayer\n */\nimport CanvasLayerRenderer from './Layer.js';\nimport ImageState from '../../ImageState.js';\nimport ViewHint from '../../ViewHint.js';\nimport {\n  apply as applyTransform,\n  compose as composeTransform,\n  makeInverse,\n  toString as toTransformString,\n} from '../../transform.js';\nimport {\n  containsCoordinate,\n  containsExtent,\n  getHeight,\n  getIntersection,\n  getWidth,\n  intersects as intersectsExtent,\n  isEmpty,\n} from '../../extent.js';\nimport {fromUserExtent} from '../../proj.js';\n\n/**\n * @classdesc\n * Canvas renderer for image layers.\n * @api\n */\nclass CanvasImageLayerRenderer extends CanvasLayerRenderer {\n  /**\n   * @param {import(\"../../layer/Image.js\").default} imageLayer Image layer.\n   */\n  constructor(imageLayer) {\n    super(imageLayer);\n\n    /**\n     * @protected\n     * @type {?import(\"../../ImageBase.js\").default}\n     */\n    this.image_ = null;\n  }\n\n  /**\n   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.\n   */\n  getImage() {\n    return this.image_ ? this.image_.getImage() : null;\n  }\n\n  /**\n   * Determine whether render should be called.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   */\n  prepareFrame(frameState) {\n    const layerState = frameState.layerStatesArray[frameState.layerIndex];\n    const pixelRatio = frameState.pixelRatio;\n    const viewState = frameState.viewState;\n    const viewResolution = viewState.resolution;\n\n    const imageSource = this.getLayer().getSource();\n\n    const hints = frameState.viewHints;\n\n    let renderedExtent = frameState.extent;\n    if (layerState.extent !== undefined) {\n      renderedExtent = getIntersection(\n        renderedExtent,\n        fromUserExtent(layerState.extent, viewState.projection)\n      );\n    }\n\n    if (\n      !hints[ViewHint.ANIMATING] &&\n      !hints[ViewHint.INTERACTING] &&\n      !isEmpty(renderedExtent)\n    ) {\n      if (imageSource) {\n        const projection = viewState.projection;\n        const image = imageSource.getImage(\n          renderedExtent,\n          viewResolution,\n          pixelRatio,\n          projection\n        );\n        if (image) {\n          if (this.loadImage(image)) {\n            this.image_ = image;\n          } else if (image.getState() === ImageState.EMPTY) {\n            this.image_ = null;\n          }\n        }\n      } else {\n        this.image_ = null;\n      }\n    }\n\n    return !!this.image_;\n  }\n\n  /**\n   * @param {import(\"../../pixel.js\").Pixel} pixel Pixel.\n   * @return {Uint8ClampedArray} Data at the pixel location.\n   */\n  getData(pixel) {\n    const frameState = this.frameState;\n    if (!frameState) {\n      return null;\n    }\n\n    const layer = this.getLayer();\n    const coordinate = applyTransform(\n      frameState.pixelToCoordinateTransform,\n      pixel.slice()\n    );\n\n    const layerExtent = layer.getExtent();\n    if (layerExtent) {\n      if (!containsCoordinate(layerExtent, coordinate)) {\n        return null;\n      }\n    }\n\n    const imageExtent = this.image_.getExtent();\n    const img = this.getImage();\n\n    const imageMapWidth = getWidth(imageExtent);\n    const col = Math.floor(\n      img.width * ((coordinate[0] - imageExtent[0]) / imageMapWidth)\n    );\n    if (col < 0 || col >= img.width) {\n      return null;\n    }\n\n    const imageMapHeight = getHeight(imageExtent);\n    const row = Math.floor(\n      img.height * ((imageExtent[3] - coordinate[1]) / imageMapHeight)\n    );\n    if (row < 0 || row >= img.height) {\n      return null;\n    }\n\n    return this.getImageData(img, col, row);\n  }\n\n  /**\n   * Render the layer.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {HTMLElement} target Target that may be used to render content to.\n   * @return {HTMLElement} The rendered element.\n   */\n  renderFrame(frameState, target) {\n    const image = this.image_;\n    const imageExtent = image.getExtent();\n    const imageResolution = image.getResolution();\n    const imagePixelRatio = image.getPixelRatio();\n    const layerState = frameState.layerStatesArray[frameState.layerIndex];\n    const pixelRatio = frameState.pixelRatio;\n    const viewState = frameState.viewState;\n    const viewCenter = viewState.center;\n    const viewResolution = viewState.resolution;\n    const scale =\n      (pixelRatio * imageResolution) / (viewResolution * imagePixelRatio);\n\n    const extent = frameState.extent;\n    const resolution = viewState.resolution;\n    const rotation = viewState.rotation;\n    // desired dimensions of the canvas in pixels\n    const width = Math.round((getWidth(extent) / resolution) * pixelRatio);\n    const height = Math.round((getHeight(extent) / resolution) * pixelRatio);\n\n    // set forward and inverse pixel transforms\n    composeTransform(\n      this.pixelTransform,\n      frameState.size[0] / 2,\n      frameState.size[1] / 2,\n      1 / pixelRatio,\n      1 / pixelRatio,\n      rotation,\n      -width / 2,\n      -height / 2\n    );\n    makeInverse(this.inversePixelTransform, this.pixelTransform);\n\n    const canvasTransform = toTransformString(this.pixelTransform);\n\n    this.useContainer(target, canvasTransform, this.getBackground(frameState));\n\n    const context = this.context;\n    const canvas = context.canvas;\n\n    if (canvas.width != width || canvas.height != height) {\n      canvas.width = width;\n      canvas.height = height;\n    } else if (!this.containerReused) {\n      context.clearRect(0, 0, width, height);\n    }\n\n    // clipped rendering if layer extent is set\n    let clipped = false;\n    let render = true;\n    if (layerState.extent) {\n      const layerExtent = fromUserExtent(\n        layerState.extent,\n        viewState.projection\n      );\n      render = intersectsExtent(layerExtent, frameState.extent);\n      clipped = render && !containsExtent(layerExtent, frameState.extent);\n      if (clipped) {\n        this.clipUnrotated(context, frameState, layerExtent);\n      }\n    }\n\n    const img = this.getImage();\n\n    const transform = composeTransform(\n      this.tempTransform,\n      width / 2,\n      height / 2,\n      scale,\n      scale,\n      0,\n      (imagePixelRatio * (imageExtent[0] - viewCenter[0])) / imageResolution,\n      (imagePixelRatio * (viewCenter[1] - imageExtent[3])) / imageResolution\n    );\n\n    this.renderedResolution = (imageResolution * pixelRatio) / imagePixelRatio;\n\n    const dw = img.width * transform[0];\n    const dh = img.height * transform[3];\n\n    if (!this.getLayer().getSource().getInterpolate()) {\n      context.imageSmoothingEnabled = false;\n    }\n\n    this.preRender(context, frameState);\n    if (render && dw >= 0.5 && dh >= 0.5) {\n      const dx = transform[4];\n      const dy = transform[5];\n      const opacity = layerState.opacity;\n      let previousAlpha;\n      if (opacity !== 1) {\n        previousAlpha = context.globalAlpha;\n        context.globalAlpha = opacity;\n      }\n      context.drawImage(img, 0, 0, +img.width, +img.height, dx, dy, dw, dh);\n      if (opacity !== 1) {\n        context.globalAlpha = previousAlpha;\n      }\n    }\n    this.postRender(context, frameState);\n\n    if (clipped) {\n      context.restore();\n    }\n    context.imageSmoothingEnabled = true;\n\n    if (canvasTransform !== canvas.style.transform) {\n      canvas.style.transform = canvasTransform;\n    }\n\n    return this.container;\n  }\n}\n\nexport default CanvasImageLayerRenderer;\n","/**\n * @module ol/format/JSONFeature\n */\nimport FeatureFormat from './Feature.js';\nimport {abstract} from '../util.js';\n\n/**\n * @classdesc\n * Abstract base class; normally only used for creating subclasses and not\n * instantiated in apps.\n * Base class for JSON feature formats.\n *\n * @abstract\n */\nclass JSONFeature extends FeatureFormat {\n  constructor() {\n    super();\n  }\n\n  /**\n   * @return {import(\"./Feature.js\").Type} Format.\n   */\n  getType() {\n    return 'json';\n  }\n\n  /**\n   * Read a feature.  Only works for a single feature. Use `readFeatures` to\n   * read a feature collection.\n   *\n   * @param {ArrayBuffer|Document|Element|Object|string} source Source.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @return {import(\"../Feature.js\").default} Feature.\n   * @api\n   */\n  readFeature(source, options) {\n    return this.readFeatureFromObject(\n      getObject(source),\n      this.getReadOptions(source, options)\n    );\n  }\n\n  /**\n   * Read all features.  Works with both a single feature and a feature\n   * collection.\n   *\n   * @param {ArrayBuffer|Document|Element|Object|string} source Source.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @return {Array<import(\"../Feature.js\").default>} Features.\n   * @api\n   */\n  readFeatures(source, options) {\n    return this.readFeaturesFromObject(\n      getObject(source),\n      this.getReadOptions(source, options)\n    );\n  }\n\n  /**\n   * @abstract\n   * @param {Object} object Object.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @protected\n   * @return {import(\"../Feature.js\").default} Feature.\n   */\n  readFeatureFromObject(object, options) {\n    return abstract();\n  }\n\n  /**\n   * @abstract\n   * @param {Object} object Object.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @protected\n   * @return {Array<import(\"../Feature.js\").default>} Features.\n   */\n  readFeaturesFromObject(object, options) {\n    return abstract();\n  }\n\n  /**\n   * Read a geometry.\n   *\n   * @param {ArrayBuffer|Document|Element|Object|string} source Source.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @return {import(\"../geom/Geometry.js\").default} Geometry.\n   * @api\n   */\n  readGeometry(source, options) {\n    return this.readGeometryFromObject(\n      getObject(source),\n      this.getReadOptions(source, options)\n    );\n  }\n\n  /**\n   * @abstract\n   * @param {Object} object Object.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @protected\n   * @return {import(\"../geom/Geometry.js\").default} Geometry.\n   */\n  readGeometryFromObject(object, options) {\n    return abstract();\n  }\n\n  /**\n   * Read the projection.\n   *\n   * @param {ArrayBuffer|Document|Element|Object|string} source Source.\n   * @return {import(\"../proj/Projection.js\").default} Projection.\n   * @api\n   */\n  readProjection(source) {\n    return this.readProjectionFromObject(getObject(source));\n  }\n\n  /**\n   * @abstract\n   * @param {Object} object Object.\n   * @protected\n   * @return {import(\"../proj/Projection.js\").default} Projection.\n   */\n  readProjectionFromObject(object) {\n    return abstract();\n  }\n\n  /**\n   * Encode a feature as string.\n   *\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n   * @return {string} Encoded feature.\n   * @api\n   */\n  writeFeature(feature, options) {\n    return JSON.stringify(this.writeFeatureObject(feature, options));\n  }\n\n  /**\n   * @abstract\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n   * @return {Object} Object.\n   */\n  writeFeatureObject(feature, options) {\n    return abstract();\n  }\n\n  /**\n   * Encode an array of features as string.\n   *\n   * @param {Array<import(\"../Feature.js\").default>} features Features.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n   * @return {string} Encoded features.\n   * @api\n   */\n  writeFeatures(features, options) {\n    return JSON.stringify(this.writeFeaturesObject(features, options));\n  }\n\n  /**\n   * @abstract\n   * @param {Array<import(\"../Feature.js\").default>} features Features.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n   * @return {Object} Object.\n   */\n  writeFeaturesObject(features, options) {\n    return abstract();\n  }\n\n  /**\n   * Encode a geometry as string.\n   *\n   * @param {import(\"../geom/Geometry.js\").default} geometry Geometry.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n   * @return {string} Encoded geometry.\n   * @api\n   */\n  writeGeometry(geometry, options) {\n    return JSON.stringify(this.writeGeometryObject(geometry, options));\n  }\n\n  /**\n   * @abstract\n   * @param {import(\"../geom/Geometry.js\").default} geometry Geometry.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n   * @return {Object} Object.\n   */\n  writeGeometryObject(geometry, options) {\n    return abstract();\n  }\n}\n\n/**\n * @param {Document|Element|Object|string} source Source.\n * @return {Object} Object.\n */\nfunction getObject(source) {\n  if (typeof source === 'string') {\n    const object = JSON.parse(source);\n    return object ? /** @type {Object} */ (object) : null;\n  }\n  if (source !== null) {\n    return source;\n  }\n  return null;\n}\n\nexport default JSONFeature;\n","/**\n * @module ol/format/GeoJSON\n */\n\nimport Feature from '../Feature.js';\nimport GeometryCollection from '../geom/GeometryCollection.js';\nimport JSONFeature from './JSONFeature.js';\nimport LineString from '../geom/LineString.js';\nimport MultiLineString from '../geom/MultiLineString.js';\nimport MultiPoint from '../geom/MultiPoint.js';\nimport MultiPolygon from '../geom/MultiPolygon.js';\nimport Point from '../geom/Point.js';\nimport Polygon from '../geom/Polygon.js';\nimport {assert} from '../asserts.js';\nimport {get as getProjection} from '../proj.js';\nimport {isEmpty} from '../obj.js';\nimport {transformGeometryWithOptions} from './Feature.js';\n\n/**\n * @typedef {import(\"geojson\").GeoJSON} GeoJSONObject\n * @typedef {import(\"geojson\").Feature} GeoJSONFeature\n * @typedef {import(\"geojson\").FeatureCollection} GeoJSONFeatureCollection\n * @typedef {import(\"geojson\").Geometry} GeoJSONGeometry\n * @typedef {import(\"geojson\").Point} GeoJSONPoint\n * @typedef {import(\"geojson\").LineString} GeoJSONLineString\n * @typedef {import(\"geojson\").Polygon} GeoJSONPolygon\n * @typedef {import(\"geojson\").MultiPoint} GeoJSONMultiPoint\n * @typedef {import(\"geojson\").MultiLineString} GeoJSONMultiLineString\n * @typedef {import(\"geojson\").MultiPolygon} GeoJSONMultiPolygon\n * @typedef {import(\"geojson\").GeometryCollection} GeoJSONGeometryCollection\n */\n\n/**\n * @typedef {Object} Options\n * @property {import(\"../proj.js\").ProjectionLike} [dataProjection='EPSG:4326'] Default data projection.\n * @property {import(\"../proj.js\").ProjectionLike} [featureProjection] Projection for features read or\n * written by the format.  Options passed to read or write methods will take precedence.\n * @property {string} [geometryName] Geometry name to use when creating features.\n * @property {boolean} [extractGeometryName=false] Certain GeoJSON providers include\n * the geometry_name field in the feature GeoJSON. If set to `true` the GeoJSON reader\n * will look for that field to set the geometry name. If both this field is set to `true`\n * and a `geometryName` is provided, the `geometryName` will take precedence.\n */\n\n/**\n * @classdesc\n * Feature format for reading and writing data in the GeoJSON format.\n *\n * @api\n */\nclass GeoJSON extends JSONFeature {\n  /**\n   * @param {Options} [options] Options.\n   */\n  constructor(options) {\n    options = options ? options : {};\n\n    super();\n\n    /**\n     * @type {import(\"../proj/Projection.js\").default}\n     */\n    this.dataProjection = getProjection(\n      options.dataProjection ? options.dataProjection : 'EPSG:4326'\n    );\n\n    if (options.featureProjection) {\n      /**\n       * @type {import(\"../proj/Projection.js\").default}\n       */\n      this.defaultFeatureProjection = getProjection(options.featureProjection);\n    }\n\n    /**\n     * Name of the geometry attribute for features.\n     * @type {string|undefined}\n     * @private\n     */\n    this.geometryName_ = options.geometryName;\n\n    /**\n     * Look for the geometry name in the feature GeoJSON\n     * @type {boolean|undefined}\n     * @private\n     */\n    this.extractGeometryName_ = options.extractGeometryName;\n\n    this.supportedMediaTypes = [\n      'application/geo+json',\n      'application/vnd.geo+json',\n    ];\n  }\n\n  /**\n   * @param {Object} object Object.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @protected\n   * @return {import(\"../Feature.js\").default} Feature.\n   */\n  readFeatureFromObject(object, options) {\n    /**\n     * @type {GeoJSONFeature}\n     */\n    let geoJSONFeature = null;\n    if (object['type'] === 'Feature') {\n      geoJSONFeature = /** @type {GeoJSONFeature} */ (object);\n    } else {\n      geoJSONFeature = {\n        'type': 'Feature',\n        'geometry': /** @type {GeoJSONGeometry} */ (object),\n        'properties': null,\n      };\n    }\n\n    const geometry = readGeometry(geoJSONFeature['geometry'], options);\n    const feature = new Feature();\n    if (this.geometryName_) {\n      feature.setGeometryName(this.geometryName_);\n    } else if (\n      this.extractGeometryName_ &&\n      'geometry_name' in geoJSONFeature !== undefined\n    ) {\n      feature.setGeometryName(geoJSONFeature['geometry_name']);\n    }\n    feature.setGeometry(geometry);\n\n    if ('id' in geoJSONFeature) {\n      feature.setId(geoJSONFeature['id']);\n    }\n\n    if (geoJSONFeature['properties']) {\n      feature.setProperties(geoJSONFeature['properties'], true);\n    }\n    return feature;\n  }\n\n  /**\n   * @param {Object} object Object.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @protected\n   * @return {Array<Feature>} Features.\n   */\n  readFeaturesFromObject(object, options) {\n    const geoJSONObject = /** @type {GeoJSONObject} */ (object);\n    /** @type {Array<import(\"../Feature.js\").default>} */\n    let features = null;\n    if (geoJSONObject['type'] === 'FeatureCollection') {\n      const geoJSONFeatureCollection = /** @type {GeoJSONFeatureCollection} */ (\n        object\n      );\n      features = [];\n      const geoJSONFeatures = geoJSONFeatureCollection['features'];\n      for (let i = 0, ii = geoJSONFeatures.length; i < ii; ++i) {\n        features.push(this.readFeatureFromObject(geoJSONFeatures[i], options));\n      }\n    } else {\n      features = [this.readFeatureFromObject(object, options)];\n    }\n    return features;\n  }\n\n  /**\n   * @param {GeoJSONGeometry} object Object.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @protected\n   * @return {import(\"../geom/Geometry.js\").default} Geometry.\n   */\n  readGeometryFromObject(object, options) {\n    return readGeometry(object, options);\n  }\n\n  /**\n   * @param {Object} object Object.\n   * @protected\n   * @return {import(\"../proj/Projection.js\").default} Projection.\n   */\n  readProjectionFromObject(object) {\n    const crs = object['crs'];\n    let projection;\n    if (crs) {\n      if (crs['type'] == 'name') {\n        projection = getProjection(crs['properties']['name']);\n      } else if (crs['type'] === 'EPSG') {\n        projection = getProjection('EPSG:' + crs['properties']['code']);\n      } else {\n        assert(false, 36); // Unknown SRS type\n      }\n    } else {\n      projection = this.dataProjection;\n    }\n    return /** @type {import(\"../proj/Projection.js\").default} */ (projection);\n  }\n\n  /**\n   * Encode a feature as a GeoJSON Feature object.\n   *\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n   * @return {GeoJSONFeature} Object.\n   * @api\n   */\n  writeFeatureObject(feature, options) {\n    options = this.adaptOptions(options);\n\n    /** @type {GeoJSONFeature} */\n    const object = {\n      'type': 'Feature',\n      geometry: null,\n      properties: null,\n    };\n\n    const id = feature.getId();\n    if (id !== undefined) {\n      object.id = id;\n    }\n\n    if (!feature.hasProperties()) {\n      return object;\n    }\n\n    const properties = feature.getProperties();\n    const geometry = feature.getGeometry();\n    if (geometry) {\n      object.geometry = writeGeometry(geometry, options);\n\n      delete properties[feature.getGeometryName()];\n    }\n\n    if (!isEmpty(properties)) {\n      object.properties = properties;\n    }\n\n    return object;\n  }\n\n  /**\n   * Encode an array of features as a GeoJSON object.\n   *\n   * @param {Array<import(\"../Feature.js\").default>} features Features.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n   * @return {GeoJSONFeatureCollection} GeoJSON Object.\n   * @api\n   */\n  writeFeaturesObject(features, options) {\n    options = this.adaptOptions(options);\n    const objects = [];\n    for (let i = 0, ii = features.length; i < ii; ++i) {\n      objects.push(this.writeFeatureObject(features[i], options));\n    }\n    return {\n      type: 'FeatureCollection',\n      features: objects,\n    };\n  }\n\n  /**\n   * Encode a geometry as a GeoJSON object.\n   *\n   * @param {import(\"../geom/Geometry.js\").default} geometry Geometry.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n   * @return {GeoJSONGeometry|GeoJSONGeometryCollection} Object.\n   * @api\n   */\n  writeGeometryObject(geometry, options) {\n    return writeGeometry(geometry, this.adaptOptions(options));\n  }\n}\n\n/**\n * @param {GeoJSONGeometry|GeoJSONGeometryCollection} object Object.\n * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n * @return {import(\"../geom/Geometry.js\").default} Geometry.\n */\nfunction readGeometry(object, options) {\n  if (!object) {\n    return null;\n  }\n\n  /**\n   * @type {import(\"../geom/Geometry.js\").default}\n   */\n  let geometry;\n  switch (object['type']) {\n    case 'Point': {\n      geometry = readPointGeometry(/** @type {GeoJSONPoint} */ (object));\n      break;\n    }\n    case 'LineString': {\n      geometry = readLineStringGeometry(\n        /** @type {GeoJSONLineString} */ (object)\n      );\n      break;\n    }\n    case 'Polygon': {\n      geometry = readPolygonGeometry(/** @type {GeoJSONPolygon} */ (object));\n      break;\n    }\n    case 'MultiPoint': {\n      geometry = readMultiPointGeometry(\n        /** @type {GeoJSONMultiPoint} */ (object)\n      );\n      break;\n    }\n    case 'MultiLineString': {\n      geometry = readMultiLineStringGeometry(\n        /** @type {GeoJSONMultiLineString} */ (object)\n      );\n      break;\n    }\n    case 'MultiPolygon': {\n      geometry = readMultiPolygonGeometry(\n        /** @type {GeoJSONMultiPolygon} */ (object)\n      );\n      break;\n    }\n    case 'GeometryCollection': {\n      geometry = readGeometryCollectionGeometry(\n        /** @type {GeoJSONGeometryCollection} */ (object)\n      );\n      break;\n    }\n    default: {\n      throw new Error('Unsupported GeoJSON type: ' + object['type']);\n    }\n  }\n  return transformGeometryWithOptions(geometry, false, options);\n}\n\n/**\n * @param {GeoJSONGeometryCollection} object Object.\n * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n * @return {GeometryCollection} Geometry collection.\n */\nfunction readGeometryCollectionGeometry(object, options) {\n  const geometries = object['geometries'].map(\n    /**\n     * @param {GeoJSONGeometry} geometry Geometry.\n     * @return {import(\"../geom/Geometry.js\").default} geometry Geometry.\n     */\n    function (geometry) {\n      return readGeometry(geometry, options);\n    }\n  );\n  return new GeometryCollection(geometries);\n}\n\n/**\n * @param {GeoJSONPoint} object Object.\n * @return {Point} Point.\n */\nfunction readPointGeometry(object) {\n  return new Point(object['coordinates']);\n}\n\n/**\n * @param {GeoJSONLineString} object Object.\n * @return {LineString} LineString.\n */\nfunction readLineStringGeometry(object) {\n  return new LineString(object['coordinates']);\n}\n\n/**\n * @param {GeoJSONMultiLineString} object Object.\n * @return {MultiLineString} MultiLineString.\n */\nfunction readMultiLineStringGeometry(object) {\n  return new MultiLineString(object['coordinates']);\n}\n\n/**\n * @param {GeoJSONMultiPoint} object Object.\n * @return {MultiPoint} MultiPoint.\n */\nfunction readMultiPointGeometry(object) {\n  return new MultiPoint(object['coordinates']);\n}\n\n/**\n * @param {GeoJSONMultiPolygon} object Object.\n * @return {MultiPolygon} MultiPolygon.\n */\nfunction readMultiPolygonGeometry(object) {\n  return new MultiPolygon(object['coordinates']);\n}\n\n/**\n * @param {GeoJSONPolygon} object Object.\n * @return {Polygon} Polygon.\n */\nfunction readPolygonGeometry(object) {\n  return new Polygon(object['coordinates']);\n}\n\n/**\n * @param {import(\"../geom/Geometry.js\").default} geometry Geometry.\n * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n * @return {GeoJSONGeometry} GeoJSON geometry.\n */\nfunction writeGeometry(geometry, options) {\n  geometry = transformGeometryWithOptions(geometry, true, options);\n  const type = geometry.getType();\n\n  /** @type {GeoJSONGeometry} */\n  let geoJSON;\n  switch (type) {\n    case 'Point': {\n      geoJSON = writePointGeometry(/** @type {Point} */ (geometry), options);\n      break;\n    }\n    case 'LineString': {\n      geoJSON = writeLineStringGeometry(\n        /** @type {LineString} */ (geometry),\n        options\n      );\n      break;\n    }\n    case 'Polygon': {\n      geoJSON = writePolygonGeometry(\n        /** @type {Polygon} */ (geometry),\n        options\n      );\n      break;\n    }\n    case 'MultiPoint': {\n      geoJSON = writeMultiPointGeometry(\n        /** @type {MultiPoint} */ (geometry),\n        options\n      );\n      break;\n    }\n    case 'MultiLineString': {\n      geoJSON = writeMultiLineStringGeometry(\n        /** @type {MultiLineString} */ (geometry),\n        options\n      );\n      break;\n    }\n    case 'MultiPolygon': {\n      geoJSON = writeMultiPolygonGeometry(\n        /** @type {MultiPolygon} */ (geometry),\n        options\n      );\n      break;\n    }\n    case 'GeometryCollection': {\n      geoJSON = writeGeometryCollectionGeometry(\n        /** @type {GeometryCollection} */ (geometry),\n        options\n      );\n      break;\n    }\n    case 'Circle': {\n      geoJSON = {\n        type: 'GeometryCollection',\n        geometries: [],\n      };\n      break;\n    }\n    default: {\n      throw new Error('Unsupported geometry type: ' + type);\n    }\n  }\n  return geoJSON;\n}\n\n/**\n * @param {GeometryCollection} geometry Geometry.\n * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n * @return {GeoJSONGeometryCollection} GeoJSON geometry collection.\n */\nfunction writeGeometryCollectionGeometry(geometry, options) {\n  options = Object.assign({}, options);\n  delete options.featureProjection;\n  const geometries = geometry.getGeometriesArray().map(function (geometry) {\n    return writeGeometry(geometry, options);\n  });\n  return {\n    type: 'GeometryCollection',\n    geometries: geometries,\n  };\n}\n\n/**\n * @param {LineString} geometry Geometry.\n * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n * @return {GeoJSONGeometry} GeoJSON geometry.\n */\nfunction writeLineStringGeometry(geometry, options) {\n  return {\n    type: 'LineString',\n    coordinates: geometry.getCoordinates(),\n  };\n}\n\n/**\n * @param {MultiLineString} geometry Geometry.\n * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n * @return {GeoJSONGeometry} GeoJSON geometry.\n */\nfunction writeMultiLineStringGeometry(geometry, options) {\n  return {\n    type: 'MultiLineString',\n    coordinates: geometry.getCoordinates(),\n  };\n}\n\n/**\n * @param {MultiPoint} geometry Geometry.\n * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n * @return {GeoJSONGeometry} GeoJSON geometry.\n */\nfunction writeMultiPointGeometry(geometry, options) {\n  return {\n    type: 'MultiPoint',\n    coordinates: geometry.getCoordinates(),\n  };\n}\n\n/**\n * @param {MultiPolygon} geometry Geometry.\n * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n * @return {GeoJSONGeometry} GeoJSON geometry.\n */\nfunction writeMultiPolygonGeometry(geometry, options) {\n  let right;\n  if (options) {\n    right = options.rightHanded;\n  }\n  return {\n    type: 'MultiPolygon',\n    coordinates: geometry.getCoordinates(right),\n  };\n}\n\n/**\n * @param {Point} geometry Geometry.\n * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n * @return {GeoJSONGeometry} GeoJSON geometry.\n */\nfunction writePointGeometry(geometry, options) {\n  return {\n    type: 'Point',\n    coordinates: geometry.getCoordinates(),\n  };\n}\n\n/**\n * @param {Polygon} geometry Geometry.\n * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n * @return {GeoJSONGeometry} GeoJSON geometry.\n */\nfunction writePolygonGeometry(geometry, options) {\n  let right;\n  if (options) {\n    right = options.rightHanded;\n  }\n  return {\n    type: 'Polygon',\n    coordinates: geometry.getCoordinates(right),\n  };\n}\n\nexport default GeoJSON;\n","/**\n * @module ol/renderer/canvas/VectorImageLayer\n */\nimport CanvasImageLayerRenderer from './ImageLayer.js';\nimport CanvasVectorLayerRenderer from './VectorLayer.js';\nimport EventType from '../../events/EventType.js';\nimport ImageCanvas from '../../ImageCanvas.js';\nimport ImageState from '../../ImageState.js';\nimport RBush from 'rbush';\nimport ViewHint from '../../ViewHint.js';\nimport {apply, compose, create} from '../../transform.js';\nimport {getHeight, getWidth, isEmpty, scaleFromCenter} from '../../extent.js';\n\n/**\n * @classdesc\n * Canvas renderer for image layers.\n * @api\n */\nclass CanvasVectorImageLayerRenderer extends CanvasImageLayerRenderer {\n  /**\n   * @param {import(\"../../layer/VectorImage.js\").default} layer Vector image layer.\n   */\n  constructor(layer) {\n    super(layer);\n\n    /**\n     * @private\n     * @type {import(\"./VectorLayer.js\").default}\n     */\n    this.vectorRenderer_ = new CanvasVectorLayerRenderer(layer);\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.layerImageRatio_ = layer.getImageRatio();\n\n    /**\n     * @private\n     * @type {import(\"../../transform.js\").Transform}\n     */\n    this.coordinateToVectorPixelTransform_ = create();\n\n    /**\n     * @private\n     * @type {import(\"../../transform.js\").Transform}\n     */\n    this.renderedPixelToCoordinateTransform_ = null;\n  }\n\n  /**\n   * Clean up.\n   */\n  disposeInternal() {\n    this.vectorRenderer_.dispose();\n    super.disposeInternal();\n  }\n\n  /**\n   * Asynchronous layer level hit detection.\n   * @param {import(\"../../pixel.js\").Pixel} pixel Pixel.\n   * @return {Promise<Array<import(\"../../Feature\").default>>} Promise that resolves with an array of features.\n   */\n  getFeatures(pixel) {\n    if (!this.vectorRenderer_) {\n      return Promise.resolve([]);\n    }\n    const vectorPixel = apply(\n      this.coordinateToVectorPixelTransform_,\n      apply(this.renderedPixelToCoordinateTransform_, pixel.slice())\n    );\n    return this.vectorRenderer_.getFeatures(vectorPixel);\n  }\n\n  /**\n   * Perform action necessary to get the layer rendered after new fonts have loaded\n   */\n  handleFontsChanged() {\n    this.vectorRenderer_.handleFontsChanged();\n  }\n\n  /**\n   * Determine whether render should be called.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   */\n  prepareFrame(frameState) {\n    const pixelRatio = frameState.pixelRatio;\n    const viewState = frameState.viewState;\n    const viewResolution = viewState.resolution;\n\n    const hints = frameState.viewHints;\n    const vectorRenderer = this.vectorRenderer_;\n    let renderedExtent = frameState.extent;\n    if (this.layerImageRatio_ !== 1) {\n      renderedExtent = renderedExtent.slice(0);\n      scaleFromCenter(renderedExtent, this.layerImageRatio_);\n    }\n    const width = getWidth(renderedExtent) / viewResolution;\n    const height = getHeight(renderedExtent) / viewResolution;\n\n    if (\n      !hints[ViewHint.ANIMATING] &&\n      !hints[ViewHint.INTERACTING] &&\n      !isEmpty(renderedExtent)\n    ) {\n      vectorRenderer.useContainer(null, null);\n      const context = vectorRenderer.context;\n      const layerState = frameState.layerStatesArray[frameState.layerIndex];\n      const imageLayerState = Object.assign({}, layerState, {opacity: 1});\n      const imageFrameState = /** @type {import(\"../../Map.js\").FrameState} */ (\n        Object.assign({}, frameState, {\n          declutterTree: new RBush(9),\n          extent: renderedExtent,\n          size: [width, height],\n          viewState: /** @type {import(\"../../View.js\").State} */ (\n            Object.assign({}, frameState.viewState, {\n              rotation: 0,\n            })\n          ),\n          layerStatesArray: [imageLayerState],\n          layerIndex: 0,\n        })\n      );\n      let emptyImage = true;\n      const image = new ImageCanvas(\n        renderedExtent,\n        viewResolution,\n        pixelRatio,\n        context.canvas,\n        function (callback) {\n          if (\n            vectorRenderer.prepareFrame(imageFrameState) &&\n            vectorRenderer.replayGroupChanged\n          ) {\n            vectorRenderer.clipping = false;\n            if (vectorRenderer.renderFrame(imageFrameState, null)) {\n              vectorRenderer.renderDeclutter(imageFrameState);\n              emptyImage = false;\n            }\n            callback();\n          }\n        }\n      );\n\n      image.addEventListener(EventType.CHANGE, () => {\n        if (image.getState() !== ImageState.LOADED) {\n          return;\n        }\n        this.image_ = emptyImage ? null : image;\n        const imageResolution = image.getResolution();\n        const imagePixelRatio = image.getPixelRatio();\n        const renderedResolution =\n          (imageResolution * pixelRatio) / imagePixelRatio;\n        this.renderedResolution = renderedResolution;\n        this.coordinateToVectorPixelTransform_ = compose(\n          this.coordinateToVectorPixelTransform_,\n          width / 2,\n          height / 2,\n          1 / renderedResolution,\n          -1 / renderedResolution,\n          0,\n          -viewState.center[0],\n          -viewState.center[1]\n        );\n      });\n      image.load();\n    }\n\n    if (this.image_) {\n      this.renderedPixelToCoordinateTransform_ =\n        frameState.pixelToCoordinateTransform.slice();\n    }\n\n    return !!this.image_;\n  }\n\n  /**\n   */\n  preRender() {}\n\n  /**\n   */\n  postRender() {}\n\n  /**\n   */\n  renderDeclutter() {}\n\n  /**\n   * @param {import(\"../../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {number} hitTolerance Hit tolerance in pixels.\n   * @param {import(\"../vector.js\").FeatureCallback<T>} callback Feature callback.\n   * @param {Array<import(\"../Map.js\").HitMatch<T>>} matches The hit detected matches with tolerance.\n   * @return {T|undefined} Callback result.\n   * @template T\n   */\n  forEachFeatureAtCoordinate(\n    coordinate,\n    frameState,\n    hitTolerance,\n    callback,\n    matches\n  ) {\n    if (this.vectorRenderer_) {\n      return this.vectorRenderer_.forEachFeatureAtCoordinate(\n        coordinate,\n        frameState,\n        hitTolerance,\n        callback,\n        matches\n      );\n    }\n    return super.forEachFeatureAtCoordinate(\n      coordinate,\n      frameState,\n      hitTolerance,\n      callback,\n      matches\n    );\n  }\n}\n\nexport default CanvasVectorImageLayerRenderer;\n","/**\n * @module ol/layer/VectorImage\n */\nimport BaseVectorLayer from './BaseVector.js';\nimport CanvasVectorImageLayerRenderer from '../renderer/canvas/VectorImageLayer.js';\n\n/**\n * @template {import(\"../source/Vector.js\").default} VectorSourceType\n * @typedef {Object} Options\n * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.\n * @property {number} [opacity=1] Opacity (0, 1).\n * @property {boolean} [visible=true] Visibility.\n * @property {import(\"../extent.js\").Extent} [extent] The bounding extent for layer rendering.  The layer will not be\n * rendered outside of this extent.\n * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers\n * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed\n * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`\n * method was used.\n * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be\n * visible.\n * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will\n * be visible.\n * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be\n * visible.\n * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will\n * be visible.\n * @property {import(\"../render.js\").OrderFunction} [renderOrder] Render order. Function to be used when sorting\n * features before rendering. By default features are drawn in the order that they are created. Use\n * `null` to avoid the sort, but get an undefined draw order.\n * @property {number} [renderBuffer=100] The buffer in pixels around the viewport extent used by the\n * renderer when getting features from the vector source for the rendering or hit-detection.\n * Recommended value: the size of the largest symbol, line width or label.\n * @property {VectorSourceType} [source] Source.\n * @property {import(\"../Map.js\").default} [map] Sets the layer as overlay on a map. The map will not manage\n * this layer in its layers collection, and the layer will be rendered on top. This is useful for\n * temporary layers. The standard way to add a layer to a map and have it managed by the map is to\n * use [map.addLayer()]{@link import(\"../Map.js\").default#addLayer}.\n * @property {boolean} [declutter=false] Declutter images and text on this layer. The priority is defined\n * by the `zIndex` of the style and the render order of features. Higher z-index means higher priority.\n * Within the same z-index, a feature rendered before another has higher priority.\n * @property {import(\"../style/Style.js\").StyleLike|null} [style] Layer style. When set to `null`, only\n * features that have their own style will be rendered. See {@link module:ol/style/Style~Style} for the default style\n * which will be used if this is not set.\n * @property {number} [imageRatio=1] Ratio by which the rendered extent should be larger than the\n * viewport extent. A larger ratio avoids cut images during panning, but will cause a decrease in performance.\n * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.\n */\n\n/**\n * @classdesc\n * Vector data is rendered client-side, to an image. This layer type provides great performance\n * during panning and zooming, but point symbols and texts are always rotated with the view and\n * pixels are scaled during zoom animations. For more accurate rendering of vector data, use\n * {@link module:ol/layer/Vector~VectorLayer} instead.\n *\n * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}\n * property on the layer object; for example, setting `title: 'My Title'` in the\n * options means that `title` is observable, and has get/set accessors.\n *\n * @template {import(\"../source/Vector.js\").default} VectorSourceType\n * @extends {BaseVectorLayer<VectorSourceType, CanvasVectorImageLayerRenderer>}\n * @api\n */\nclass VectorImageLayer extends BaseVectorLayer {\n  /**\n   * @param {Options<VectorSourceType>} [options] Options.\n   */\n  constructor(options) {\n    options = options ? options : {};\n\n    const baseOptions = Object.assign({}, options);\n    delete baseOptions.imageRatio;\n    super(baseOptions);\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.imageRatio_ =\n      options.imageRatio !== undefined ? options.imageRatio : 1;\n  }\n\n  /**\n   * @return {number} Ratio between rendered extent size and viewport extent size.\n   */\n  getImageRatio() {\n    return this.imageRatio_;\n  }\n\n  createRenderer() {\n    return new CanvasVectorImageLayerRenderer(this);\n  }\n}\n\nexport default VectorImageLayer;\n","import { useEffect } from \"react\";\nimport { useMap } from \"../../contexts/mapContext\";\nimport { FeatureCollection } from \"geojson\";\nimport VectorSource from \"ol/source/Vector\";\nimport GeoJSON from \"ol/format/GeoJSON\";\nimport VectorImageLayer from \"ol/layer/VectorImage\";\nimport Style from \"ol/style/Style\";\nimport Fill, { Options as FillOptions } from \"ol/style/Fill\";\nimport Stroke, { Options as StrokeOptions } from \"ol/style/Stroke\";\nimport { useRef } from \"preact/hooks\";\nimport BaseLayer from \"ol/layer/Base\";\n\ninterface MapLayerProps {\n  features: FeatureCollection;\n  stroke: StrokeOptions;\n  fill: FillOptions;\n}\n\nconst MapLayer = ({ features, stroke, fill }: MapLayerProps) => {\n  const map = useMap();\n  const layer = useRef<BaseLayer | null>(null);\n\n  useEffect(() => {\n    if (layer.current) {\n      map.removeLayer(layer.current);\n      layer.current = null;\n    }\n\n    const source = new VectorSource({\n      features: new GeoJSON().readFeatures(features),\n    });\n    layer.current = new VectorImageLayer({\n      source,\n      style: new Style({\n        fill: new Fill(fill),\n        stroke: new Stroke(stroke),\n      }),\n    });\n    map.addLayer(layer.current);\n\n    return () => {\n      layer.current && map?.removeLayer(layer.current);\n    };\n  }, [features, map, layer, stroke, fill]);\n\n  return null;\n};\n\nexport default MapLayer;\n"],"names":["ImageBase","EventTarget","extent","resolution","pixelRatio","state","EventType","abstract","ImageBase$1","ImageCanvas","canvas","loader","ImageState","err","ImageCanvas$1","CanvasImageLayerRenderer","CanvasLayerRenderer","imageLayer","frameState","layerState","viewState","viewResolution","imageSource","hints","renderedExtent","getIntersection","fromUserExtent","ViewHint","isEmpty","projection","image","pixel","layer","coordinate","applyTransform","layerExtent","containsCoordinate","imageExtent","img","imageMapWidth","getWidth","col","imageMapHeight","getHeight","row","target","imageResolution","imagePixelRatio","viewCenter","scale","rotation","width","height","composeTransform","makeInverse","canvasTransform","toTransformString","context","clipped","render","intersectsExtent","containsExtent","transform","dw","dh","dx","dy","opacity","previousAlpha","CanvasImageLayerRenderer$1","JSONFeature","FeatureFormat","source","options","getObject","object","feature","features","geometry","JSONFeature$1","GeoJSON","getProjection","geoJSONFeature","readGeometry","Feature","geoJSONObject","geoJSONFeatureCollection","geoJSONFeatures","i","ii","crs","assert","id","properties","writeGeometry","objects","readPointGeometry","readLineStringGeometry","readPolygonGeometry","readMultiPointGeometry","readMultiLineStringGeometry","readMultiPolygonGeometry","readGeometryCollectionGeometry","transformGeometryWithOptions","geometries","GeometryCollection","Point","LineString","MultiLineString","MultiPoint","MultiPolygon","Polygon","type","geoJSON","writePointGeometry","writeLineStringGeometry","writePolygonGeometry","writeMultiPointGeometry","writeMultiLineStringGeometry","writeMultiPolygonGeometry","writeGeometryCollectionGeometry","right","GeoJSON$1","CanvasVectorImageLayerRenderer","CanvasVectorLayerRenderer","create","vectorPixel","apply","vectorRenderer","scaleFromCenter","imageLayerState","imageFrameState","RBush","emptyImage","callback","renderedResolution","compose","hitTolerance","matches","CanvasVectorImageLayerRenderer$1","VectorImageLayer","BaseVectorLayer","baseOptions","VectorImageLayer$1","MapLayer","stroke","fill","map","useMap","useRef","useEffect","current","removeLayer","VectorSource","readFeatures","style","Style","Fill","Stroke","addLayer"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6]}