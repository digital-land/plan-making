{"version":3,"file":"mapLayer-cce135b9.js","sources":["../../node_modules/ol/ImageBase.js","../../node_modules/ol/ImageCanvas.js","../../node_modules/ol/renderer/canvas/ImageLayer.js","../../node_modules/ol/format/Feature.js","../../node_modules/ol/format/JSONFeature.js","../../node_modules/ol/format/GeoJSON.js","../../node_modules/ol/renderer/canvas/VectorImageLayer.js","../../node_modules/ol/layer/VectorImage.js","../../src/components/maps/mapLayer.tsx"],"sourcesContent":["/**\n * @module ol/ImageBase\n */\nimport EventTarget from './events/Target.js';\nimport EventType from './events/EventType.js';\nimport {abstract} from './util.js';\n\n/**\n * @abstract\n */\nclass ImageBase extends EventTarget {\n  /**\n   * @param {import(\"./extent.js\").Extent} extent Extent.\n   * @param {number|undefined} resolution Resolution.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"./ImageState.js\").default} state State.\n   */\n  constructor(extent, resolution, pixelRatio, state) {\n    super();\n\n    /**\n     * @protected\n     * @type {import(\"./extent.js\").Extent}\n     */\n    this.extent = extent;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.pixelRatio_ = pixelRatio;\n\n    /**\n     * @protected\n     * @type {number|undefined}\n     */\n    this.resolution = resolution;\n\n    /**\n     * @protected\n     * @type {import(\"./ImageState.js\").default}\n     */\n    this.state = state;\n  }\n\n  /**\n   * @protected\n   */\n  changed() {\n    this.dispatchEvent(EventType.CHANGE);\n  }\n\n  /**\n   * @return {import(\"./extent.js\").Extent} Extent.\n   */\n  getExtent() {\n    return this.extent;\n  }\n\n  /**\n   * @abstract\n   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.\n   */\n  getImage() {\n    return abstract();\n  }\n\n  /**\n   * @return {number} PixelRatio.\n   */\n  getPixelRatio() {\n    return this.pixelRatio_;\n  }\n\n  /**\n   * @return {number} Resolution.\n   */\n  getResolution() {\n    return /** @type {number} */ (this.resolution);\n  }\n\n  /**\n   * @return {import(\"./ImageState.js\").default} State.\n   */\n  getState() {\n    return this.state;\n  }\n\n  /**\n   * Load not yet loaded URI.\n   * @abstract\n   */\n  load() {\n    abstract();\n  }\n}\n\nexport default ImageBase;\n","/**\n * @module ol/ImageCanvas\n */\nimport ImageBase from './ImageBase.js';\nimport ImageState from './ImageState.js';\n\n/**\n * A function that is called to trigger asynchronous canvas drawing.  It is\n * called with a \"done\" callback that should be called when drawing is done.\n * If any error occurs during drawing, the \"done\" callback should be called with\n * that error.\n *\n * @typedef {function(function(Error=): void): void} Loader\n */\n\nclass ImageCanvas extends ImageBase {\n  /**\n   * @param {import(\"./extent.js\").Extent} extent Extent.\n   * @param {number} resolution Resolution.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {HTMLCanvasElement} canvas Canvas.\n   * @param {Loader} [loader] Optional loader function to\n   *     support asynchronous canvas drawing.\n   */\n  constructor(extent, resolution, pixelRatio, canvas, loader) {\n    const state = loader !== undefined ? ImageState.IDLE : ImageState.LOADED;\n\n    super(extent, resolution, pixelRatio, state);\n\n    /**\n     * Optional canvas loader function.\n     * @type {?Loader}\n     * @private\n     */\n    this.loader_ = loader !== undefined ? loader : null;\n\n    /**\n     * @private\n     * @type {HTMLCanvasElement}\n     */\n    this.canvas_ = canvas;\n\n    /**\n     * @private\n     * @type {?Error}\n     */\n    this.error_ = null;\n  }\n\n  /**\n   * Get any error associated with asynchronous rendering.\n   * @return {?Error} Any error that occurred during rendering.\n   */\n  getError() {\n    return this.error_;\n  }\n\n  /**\n   * Handle async drawing complete.\n   * @param {Error} [err] Any error during drawing.\n   * @private\n   */\n  handleLoad_(err) {\n    if (err) {\n      this.error_ = err;\n      this.state = ImageState.ERROR;\n    } else {\n      this.state = ImageState.LOADED;\n    }\n    this.changed();\n  }\n\n  /**\n   * Load not yet loaded URI.\n   */\n  load() {\n    if (this.state == ImageState.IDLE) {\n      this.state = ImageState.LOADING;\n      this.changed();\n      this.loader_(this.handleLoad_.bind(this));\n    }\n  }\n\n  /**\n   * @return {HTMLCanvasElement} Canvas element.\n   */\n  getImage() {\n    return this.canvas_;\n  }\n}\n\nexport default ImageCanvas;\n","/**\n * @module ol/renderer/canvas/ImageLayer\n */\nimport CanvasLayerRenderer from './Layer.js';\nimport ImageState from '../../ImageState.js';\nimport ViewHint from '../../ViewHint.js';\nimport {\n  apply as applyTransform,\n  compose as composeTransform,\n  makeInverse,\n  toString as toTransformString,\n} from '../../transform.js';\nimport {\n  containsCoordinate,\n  containsExtent,\n  getHeight,\n  getIntersection,\n  getWidth,\n  intersects as intersectsExtent,\n  isEmpty,\n} from '../../extent.js';\nimport {fromUserExtent} from '../../proj.js';\n\n/**\n * @classdesc\n * Canvas renderer for image layers.\n * @api\n */\nclass CanvasImageLayerRenderer extends CanvasLayerRenderer {\n  /**\n   * @param {import(\"../../layer/Image.js\").default} imageLayer Image layer.\n   */\n  constructor(imageLayer) {\n    super(imageLayer);\n\n    /**\n     * @protected\n     * @type {?import(\"../../ImageBase.js\").default}\n     */\n    this.image_ = null;\n  }\n\n  /**\n   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.\n   */\n  getImage() {\n    return this.image_ ? this.image_.getImage() : null;\n  }\n\n  /**\n   * Determine whether render should be called.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   */\n  prepareFrame(frameState) {\n    const layerState = frameState.layerStatesArray[frameState.layerIndex];\n    const pixelRatio = frameState.pixelRatio;\n    const viewState = frameState.viewState;\n    const viewResolution = viewState.resolution;\n\n    const imageSource = this.getLayer().getSource();\n\n    const hints = frameState.viewHints;\n\n    let renderedExtent = frameState.extent;\n    if (layerState.extent !== undefined) {\n      renderedExtent = getIntersection(\n        renderedExtent,\n        fromUserExtent(layerState.extent, viewState.projection)\n      );\n    }\n\n    if (\n      !hints[ViewHint.ANIMATING] &&\n      !hints[ViewHint.INTERACTING] &&\n      !isEmpty(renderedExtent)\n    ) {\n      if (imageSource) {\n        const projection = viewState.projection;\n        const image = imageSource.getImage(\n          renderedExtent,\n          viewResolution,\n          pixelRatio,\n          projection\n        );\n        if (image) {\n          if (this.loadImage(image)) {\n            this.image_ = image;\n          } else if (image.getState() === ImageState.EMPTY) {\n            this.image_ = null;\n          }\n        }\n      } else {\n        this.image_ = null;\n      }\n    }\n\n    return !!this.image_;\n  }\n\n  /**\n   * @param {import(\"../../pixel.js\").Pixel} pixel Pixel.\n   * @return {Uint8ClampedArray} Data at the pixel location.\n   */\n  getData(pixel) {\n    const frameState = this.frameState;\n    if (!frameState) {\n      return null;\n    }\n\n    const layer = this.getLayer();\n    const coordinate = applyTransform(\n      frameState.pixelToCoordinateTransform,\n      pixel.slice()\n    );\n\n    const layerExtent = layer.getExtent();\n    if (layerExtent) {\n      if (!containsCoordinate(layerExtent, coordinate)) {\n        return null;\n      }\n    }\n\n    const imageExtent = this.image_.getExtent();\n    const img = this.getImage();\n\n    const imageMapWidth = getWidth(imageExtent);\n    const col = Math.floor(\n      img.width * ((coordinate[0] - imageExtent[0]) / imageMapWidth)\n    );\n    if (col < 0 || col >= img.width) {\n      return null;\n    }\n\n    const imageMapHeight = getHeight(imageExtent);\n    const row = Math.floor(\n      img.height * ((imageExtent[3] - coordinate[1]) / imageMapHeight)\n    );\n    if (row < 0 || row >= img.height) {\n      return null;\n    }\n\n    return this.getImageData(img, col, row);\n  }\n\n  /**\n   * Render the layer.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {HTMLElement} target Target that may be used to render content to.\n   * @return {HTMLElement} The rendered element.\n   */\n  renderFrame(frameState, target) {\n    const image = this.image_;\n    const imageExtent = image.getExtent();\n    const imageResolution = image.getResolution();\n    const imagePixelRatio = image.getPixelRatio();\n    const layerState = frameState.layerStatesArray[frameState.layerIndex];\n    const pixelRatio = frameState.pixelRatio;\n    const viewState = frameState.viewState;\n    const viewCenter = viewState.center;\n    const viewResolution = viewState.resolution;\n    const scale =\n      (pixelRatio * imageResolution) / (viewResolution * imagePixelRatio);\n\n    const extent = frameState.extent;\n    const resolution = viewState.resolution;\n    const rotation = viewState.rotation;\n    // desired dimensions of the canvas in pixels\n    const width = Math.round((getWidth(extent) / resolution) * pixelRatio);\n    const height = Math.round((getHeight(extent) / resolution) * pixelRatio);\n\n    // set forward and inverse pixel transforms\n    composeTransform(\n      this.pixelTransform,\n      frameState.size[0] / 2,\n      frameState.size[1] / 2,\n      1 / pixelRatio,\n      1 / pixelRatio,\n      rotation,\n      -width / 2,\n      -height / 2\n    );\n    makeInverse(this.inversePixelTransform, this.pixelTransform);\n\n    const canvasTransform = toTransformString(this.pixelTransform);\n\n    this.useContainer(target, canvasTransform, this.getBackground(frameState));\n\n    const context = this.context;\n    const canvas = context.canvas;\n\n    if (canvas.width != width || canvas.height != height) {\n      canvas.width = width;\n      canvas.height = height;\n    } else if (!this.containerReused) {\n      context.clearRect(0, 0, width, height);\n    }\n\n    // clipped rendering if layer extent is set\n    let clipped = false;\n    let render = true;\n    if (layerState.extent) {\n      const layerExtent = fromUserExtent(\n        layerState.extent,\n        viewState.projection\n      );\n      render = intersectsExtent(layerExtent, frameState.extent);\n      clipped = render && !containsExtent(layerExtent, frameState.extent);\n      if (clipped) {\n        this.clipUnrotated(context, frameState, layerExtent);\n      }\n    }\n\n    const img = this.getImage();\n\n    const transform = composeTransform(\n      this.tempTransform,\n      width / 2,\n      height / 2,\n      scale,\n      scale,\n      0,\n      (imagePixelRatio * (imageExtent[0] - viewCenter[0])) / imageResolution,\n      (imagePixelRatio * (viewCenter[1] - imageExtent[3])) / imageResolution\n    );\n\n    this.renderedResolution = (imageResolution * pixelRatio) / imagePixelRatio;\n\n    const dw = img.width * transform[0];\n    const dh = img.height * transform[3];\n\n    if (!this.getLayer().getSource().getInterpolate()) {\n      context.imageSmoothingEnabled = false;\n    }\n\n    this.preRender(context, frameState);\n    if (render && dw >= 0.5 && dh >= 0.5) {\n      const dx = transform[4];\n      const dy = transform[5];\n      const opacity = layerState.opacity;\n      let previousAlpha;\n      if (opacity !== 1) {\n        previousAlpha = context.globalAlpha;\n        context.globalAlpha = opacity;\n      }\n      context.drawImage(img, 0, 0, +img.width, +img.height, dx, dy, dw, dh);\n      if (opacity !== 1) {\n        context.globalAlpha = previousAlpha;\n      }\n    }\n    this.postRender(context, frameState);\n\n    if (clipped) {\n      context.restore();\n    }\n    context.imageSmoothingEnabled = true;\n\n    if (canvasTransform !== canvas.style.transform) {\n      canvas.style.transform = canvasTransform;\n    }\n\n    return this.container;\n  }\n}\n\nexport default CanvasImageLayerRenderer;\n","/**\n * @module ol/format/Feature\n */\nimport {abstract} from '../util.js';\nimport {\n  equivalent as equivalentProjection,\n  get as getProjection,\n  transformExtent,\n} from '../proj.js';\n\n/**\n * @typedef {Object} ReadOptions\n * @property {import(\"../proj.js\").ProjectionLike} [dataProjection] Projection of the data we are reading.\n * If not provided, the projection will be derived from the data (where possible) or\n * the `dataProjection` of the format is assigned (where set). If the projection\n * can not be derived from the data and if no `dataProjection` is set for a format,\n * the features will not be reprojected.\n * @property {import(\"../extent.js\").Extent} [extent] Tile extent in map units of the tile being read.\n * This is only required when reading data with tile pixels as geometry units. When configured,\n * a `dataProjection` with `TILE_PIXELS` as `units` and the tile's pixel extent as `extent` needs to be\n * provided.\n * @property {import(\"../proj.js\").ProjectionLike} [featureProjection] Projection of the feature geometries\n * created by the format reader. If not provided, features will be returned in the\n * `dataProjection`.\n */\n\n/**\n * @typedef {Object} WriteOptions\n * @property {import(\"../proj.js\").ProjectionLike} [dataProjection] Projection of the data we are writing.\n * If not provided, the `dataProjection` of the format is assigned (where set).\n * If no `dataProjection` is set for a format, the features will be returned\n * in the `featureProjection`.\n * @property {import(\"../proj.js\").ProjectionLike} [featureProjection] Projection of the feature geometries\n * that will be serialized by the format writer. If not provided, geometries are assumed\n * to be in the `dataProjection` if that is set; in other words, they are not transformed.\n * @property {boolean} [rightHanded] When writing geometries, follow the right-hand\n * rule for linear ring orientation.  This means that polygons will have counter-clockwise\n * exterior rings and clockwise interior rings.  By default, coordinates are serialized\n * as they are provided at construction.  If `true`, the right-hand rule will\n * be applied.  If `false`, the left-hand rule will be applied (clockwise for\n * exterior and counter-clockwise for interior rings).  Note that not all\n * formats support this.  The GeoJSON format does use this property when writing\n * geometries.\n * @property {number} [decimals] Maximum number of decimal places for coordinates.\n * Coordinates are stored internally as floats, but floating-point arithmetic can create\n * coordinates with a large number of decimal places, not generally wanted on output.\n * Set a number here to round coordinates. Can also be used to ensure that\n * coordinates read in can be written back out with the same number of decimals.\n * Default is no rounding.\n */\n\n/**\n * @typedef {'arraybuffer' | 'json' | 'text' | 'xml'} Type\n */\n\n/**\n * @classdesc\n * Abstract base class; normally only used for creating subclasses and not\n * instantiated in apps.\n * Base class for feature formats.\n * {@link module:ol/format/Feature~FeatureFormat} subclasses provide the ability to decode and encode\n * {@link module:ol/Feature~Feature} objects from a variety of commonly used geospatial\n * file formats.  See the documentation for each format for more details.\n *\n * @abstract\n * @api\n */\nclass FeatureFormat {\n  constructor() {\n    /**\n     * @protected\n     * @type {import(\"../proj/Projection.js\").default|undefined}\n     */\n    this.dataProjection = undefined;\n\n    /**\n     * @protected\n     * @type {import(\"../proj/Projection.js\").default|undefined}\n     */\n    this.defaultFeatureProjection = undefined;\n\n    /**\n     * A list media types supported by the format in descending order of preference.\n     * @type {Array<string>}\n     */\n    this.supportedMediaTypes = null;\n  }\n\n  /**\n   * Adds the data projection to the read options.\n   * @param {Document|Element|Object|string} source Source.\n   * @param {ReadOptions} [options] Options.\n   * @return {ReadOptions|undefined} Options.\n   * @protected\n   */\n  getReadOptions(source, options) {\n    if (options) {\n      let dataProjection = options.dataProjection\n        ? getProjection(options.dataProjection)\n        : this.readProjection(source);\n      if (\n        options.extent &&\n        dataProjection &&\n        dataProjection.getUnits() === 'tile-pixels'\n      ) {\n        dataProjection = getProjection(dataProjection);\n        dataProjection.setWorldExtent(options.extent);\n      }\n      options = {\n        dataProjection: dataProjection,\n        featureProjection: options.featureProjection,\n      };\n    }\n    return this.adaptOptions(options);\n  }\n\n  /**\n   * Sets the `dataProjection` on the options, if no `dataProjection`\n   * is set.\n   * @param {WriteOptions|ReadOptions|undefined} options\n   *     Options.\n   * @protected\n   * @return {WriteOptions|ReadOptions|undefined}\n   *     Updated options.\n   */\n  adaptOptions(options) {\n    return Object.assign(\n      {\n        dataProjection: this.dataProjection,\n        featureProjection: this.defaultFeatureProjection,\n      },\n      options\n    );\n  }\n\n  /**\n   * @abstract\n   * @return {Type} The format type.\n   */\n  getType() {\n    return abstract();\n  }\n\n  /**\n   * Read a single feature from a source.\n   *\n   * @abstract\n   * @param {Document|Element|Object|string} source Source.\n   * @param {ReadOptions} [options] Read options.\n   * @return {import(\"../Feature.js\").FeatureLike} Feature.\n   */\n  readFeature(source, options) {\n    return abstract();\n  }\n\n  /**\n   * Read all features from a source.\n   *\n   * @abstract\n   * @param {Document|Element|ArrayBuffer|Object|string} source Source.\n   * @param {ReadOptions} [options] Read options.\n   * @return {Array<import(\"../Feature.js\").FeatureLike>} Features.\n   */\n  readFeatures(source, options) {\n    return abstract();\n  }\n\n  /**\n   * Read a single geometry from a source.\n   *\n   * @abstract\n   * @param {Document|Element|Object|string} source Source.\n   * @param {ReadOptions} [options] Read options.\n   * @return {import(\"../geom/Geometry.js\").default} Geometry.\n   */\n  readGeometry(source, options) {\n    return abstract();\n  }\n\n  /**\n   * Read the projection from a source.\n   *\n   * @abstract\n   * @param {Document|Element|Object|string} source Source.\n   * @return {import(\"../proj/Projection.js\").default|undefined} Projection.\n   */\n  readProjection(source) {\n    return abstract();\n  }\n\n  /**\n   * Encode a feature in this format.\n   *\n   * @abstract\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @param {WriteOptions} [options] Write options.\n   * @return {string|ArrayBuffer} Result.\n   */\n  writeFeature(feature, options) {\n    return abstract();\n  }\n\n  /**\n   * Encode an array of features in this format.\n   *\n   * @abstract\n   * @param {Array<import(\"../Feature.js\").default>} features Features.\n   * @param {WriteOptions} [options] Write options.\n   * @return {string|ArrayBuffer} Result.\n   */\n  writeFeatures(features, options) {\n    return abstract();\n  }\n\n  /**\n   * Write a single geometry in this format.\n   *\n   * @abstract\n   * @param {import(\"../geom/Geometry.js\").default} geometry Geometry.\n   * @param {WriteOptions} [options] Write options.\n   * @return {string|ArrayBuffer} Result.\n   */\n  writeGeometry(geometry, options) {\n    return abstract();\n  }\n}\n\nexport default FeatureFormat;\n\n/**\n * @param {import(\"../geom/Geometry.js\").default} geometry Geometry.\n * @param {boolean} write Set to true for writing, false for reading.\n * @param {WriteOptions|ReadOptions} [options] Options.\n * @return {import(\"../geom/Geometry.js\").default} Transformed geometry.\n */\nexport function transformGeometryWithOptions(geometry, write, options) {\n  const featureProjection = options\n    ? getProjection(options.featureProjection)\n    : null;\n  const dataProjection = options ? getProjection(options.dataProjection) : null;\n\n  let transformed;\n  if (\n    featureProjection &&\n    dataProjection &&\n    !equivalentProjection(featureProjection, dataProjection)\n  ) {\n    transformed = (write ? geometry.clone() : geometry).transform(\n      write ? featureProjection : dataProjection,\n      write ? dataProjection : featureProjection\n    );\n  } else {\n    transformed = geometry;\n  }\n  if (\n    write &&\n    options &&\n    /** @type {WriteOptions} */ (options).decimals !== undefined\n  ) {\n    const power = Math.pow(10, /** @type {WriteOptions} */ (options).decimals);\n    // if decimals option on write, round each coordinate appropriately\n    /**\n     * @param {Array<number>} coordinates Coordinates.\n     * @return {Array<number>} Transformed coordinates.\n     */\n    const transform = function (coordinates) {\n      for (let i = 0, ii = coordinates.length; i < ii; ++i) {\n        coordinates[i] = Math.round(coordinates[i] * power) / power;\n      }\n      return coordinates;\n    };\n    if (transformed === geometry) {\n      transformed = geometry.clone();\n    }\n    transformed.applyTransform(transform);\n  }\n  return transformed;\n}\n\n/**\n * @param {import(\"../extent.js\").Extent} extent Extent.\n * @param {ReadOptions} [options] Read options.\n * @return {import(\"../extent.js\").Extent} Transformed extent.\n */\nexport function transformExtentWithOptions(extent, options) {\n  const featureProjection = options\n    ? getProjection(options.featureProjection)\n    : null;\n  const dataProjection = options ? getProjection(options.dataProjection) : null;\n\n  if (\n    featureProjection &&\n    dataProjection &&\n    !equivalentProjection(featureProjection, dataProjection)\n  ) {\n    return transformExtent(extent, dataProjection, featureProjection);\n  }\n  return extent;\n}\n","/**\n * @module ol/format/JSONFeature\n */\nimport FeatureFormat from './Feature.js';\nimport {abstract} from '../util.js';\n\n/**\n * @classdesc\n * Abstract base class; normally only used for creating subclasses and not\n * instantiated in apps.\n * Base class for JSON feature formats.\n *\n * @abstract\n */\nclass JSONFeature extends FeatureFormat {\n  constructor() {\n    super();\n  }\n\n  /**\n   * @return {import(\"./Feature.js\").Type} Format.\n   */\n  getType() {\n    return 'json';\n  }\n\n  /**\n   * Read a feature.  Only works for a single feature. Use `readFeatures` to\n   * read a feature collection.\n   *\n   * @param {ArrayBuffer|Document|Element|Object|string} source Source.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @return {import(\"../Feature.js\").default} Feature.\n   * @api\n   */\n  readFeature(source, options) {\n    return this.readFeatureFromObject(\n      getObject(source),\n      this.getReadOptions(source, options)\n    );\n  }\n\n  /**\n   * Read all features.  Works with both a single feature and a feature\n   * collection.\n   *\n   * @param {ArrayBuffer|Document|Element|Object|string} source Source.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @return {Array<import(\"../Feature.js\").default>} Features.\n   * @api\n   */\n  readFeatures(source, options) {\n    return this.readFeaturesFromObject(\n      getObject(source),\n      this.getReadOptions(source, options)\n    );\n  }\n\n  /**\n   * @abstract\n   * @param {Object} object Object.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @protected\n   * @return {import(\"../Feature.js\").default} Feature.\n   */\n  readFeatureFromObject(object, options) {\n    return abstract();\n  }\n\n  /**\n   * @abstract\n   * @param {Object} object Object.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @protected\n   * @return {Array<import(\"../Feature.js\").default>} Features.\n   */\n  readFeaturesFromObject(object, options) {\n    return abstract();\n  }\n\n  /**\n   * Read a geometry.\n   *\n   * @param {ArrayBuffer|Document|Element|Object|string} source Source.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @return {import(\"../geom/Geometry.js\").default} Geometry.\n   * @api\n   */\n  readGeometry(source, options) {\n    return this.readGeometryFromObject(\n      getObject(source),\n      this.getReadOptions(source, options)\n    );\n  }\n\n  /**\n   * @abstract\n   * @param {Object} object Object.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @protected\n   * @return {import(\"../geom/Geometry.js\").default} Geometry.\n   */\n  readGeometryFromObject(object, options) {\n    return abstract();\n  }\n\n  /**\n   * Read the projection.\n   *\n   * @param {ArrayBuffer|Document|Element|Object|string} source Source.\n   * @return {import(\"../proj/Projection.js\").default} Projection.\n   * @api\n   */\n  readProjection(source) {\n    return this.readProjectionFromObject(getObject(source));\n  }\n\n  /**\n   * @abstract\n   * @param {Object} object Object.\n   * @protected\n   * @return {import(\"../proj/Projection.js\").default} Projection.\n   */\n  readProjectionFromObject(object) {\n    return abstract();\n  }\n\n  /**\n   * Encode a feature as string.\n   *\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n   * @return {string} Encoded feature.\n   * @api\n   */\n  writeFeature(feature, options) {\n    return JSON.stringify(this.writeFeatureObject(feature, options));\n  }\n\n  /**\n   * @abstract\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n   * @return {Object} Object.\n   */\n  writeFeatureObject(feature, options) {\n    return abstract();\n  }\n\n  /**\n   * Encode an array of features as string.\n   *\n   * @param {Array<import(\"../Feature.js\").default>} features Features.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n   * @return {string} Encoded features.\n   * @api\n   */\n  writeFeatures(features, options) {\n    return JSON.stringify(this.writeFeaturesObject(features, options));\n  }\n\n  /**\n   * @abstract\n   * @param {Array<import(\"../Feature.js\").default>} features Features.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n   * @return {Object} Object.\n   */\n  writeFeaturesObject(features, options) {\n    return abstract();\n  }\n\n  /**\n   * Encode a geometry as string.\n   *\n   * @param {import(\"../geom/Geometry.js\").default} geometry Geometry.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n   * @return {string} Encoded geometry.\n   * @api\n   */\n  writeGeometry(geometry, options) {\n    return JSON.stringify(this.writeGeometryObject(geometry, options));\n  }\n\n  /**\n   * @abstract\n   * @param {import(\"../geom/Geometry.js\").default} geometry Geometry.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n   * @return {Object} Object.\n   */\n  writeGeometryObject(geometry, options) {\n    return abstract();\n  }\n}\n\n/**\n * @param {Document|Element|Object|string} source Source.\n * @return {Object} Object.\n */\nfunction getObject(source) {\n  if (typeof source === 'string') {\n    const object = JSON.parse(source);\n    return object ? /** @type {Object} */ (object) : null;\n  }\n  if (source !== null) {\n    return source;\n  }\n  return null;\n}\n\nexport default JSONFeature;\n","/**\n * @module ol/format/GeoJSON\n */\n\nimport Feature from '../Feature.js';\nimport GeometryCollection from '../geom/GeometryCollection.js';\nimport JSONFeature from './JSONFeature.js';\nimport LineString from '../geom/LineString.js';\nimport MultiLineString from '../geom/MultiLineString.js';\nimport MultiPoint from '../geom/MultiPoint.js';\nimport MultiPolygon from '../geom/MultiPolygon.js';\nimport Point from '../geom/Point.js';\nimport Polygon from '../geom/Polygon.js';\nimport {assert} from '../asserts.js';\nimport {get as getProjection} from '../proj.js';\nimport {isEmpty} from '../obj.js';\nimport {transformGeometryWithOptions} from './Feature.js';\n\n/**\n * @typedef {import(\"geojson\").GeoJSON} GeoJSONObject\n * @typedef {import(\"geojson\").Feature} GeoJSONFeature\n * @typedef {import(\"geojson\").FeatureCollection} GeoJSONFeatureCollection\n * @typedef {import(\"geojson\").Geometry} GeoJSONGeometry\n * @typedef {import(\"geojson\").Point} GeoJSONPoint\n * @typedef {import(\"geojson\").LineString} GeoJSONLineString\n * @typedef {import(\"geojson\").Polygon} GeoJSONPolygon\n * @typedef {import(\"geojson\").MultiPoint} GeoJSONMultiPoint\n * @typedef {import(\"geojson\").MultiLineString} GeoJSONMultiLineString\n * @typedef {import(\"geojson\").MultiPolygon} GeoJSONMultiPolygon\n * @typedef {import(\"geojson\").GeometryCollection} GeoJSONGeometryCollection\n */\n\n/**\n * @typedef {Object} Options\n * @property {import(\"../proj.js\").ProjectionLike} [dataProjection='EPSG:4326'] Default data projection.\n * @property {import(\"../proj.js\").ProjectionLike} [featureProjection] Projection for features read or\n * written by the format.  Options passed to read or write methods will take precedence.\n * @property {string} [geometryName] Geometry name to use when creating features.\n * @property {boolean} [extractGeometryName=false] Certain GeoJSON providers include\n * the geometry_name field in the feature GeoJSON. If set to `true` the GeoJSON reader\n * will look for that field to set the geometry name. If both this field is set to `true`\n * and a `geometryName` is provided, the `geometryName` will take precedence.\n */\n\n/**\n * @classdesc\n * Feature format for reading and writing data in the GeoJSON format.\n *\n * @api\n */\nclass GeoJSON extends JSONFeature {\n  /**\n   * @param {Options} [options] Options.\n   */\n  constructor(options) {\n    options = options ? options : {};\n\n    super();\n\n    /**\n     * @type {import(\"../proj/Projection.js\").default}\n     */\n    this.dataProjection = getProjection(\n      options.dataProjection ? options.dataProjection : 'EPSG:4326'\n    );\n\n    if (options.featureProjection) {\n      /**\n       * @type {import(\"../proj/Projection.js\").default}\n       */\n      this.defaultFeatureProjection = getProjection(options.featureProjection);\n    }\n\n    /**\n     * Name of the geometry attribute for features.\n     * @type {string|undefined}\n     * @private\n     */\n    this.geometryName_ = options.geometryName;\n\n    /**\n     * Look for the geometry name in the feature GeoJSON\n     * @type {boolean|undefined}\n     * @private\n     */\n    this.extractGeometryName_ = options.extractGeometryName;\n\n    this.supportedMediaTypes = [\n      'application/geo+json',\n      'application/vnd.geo+json',\n    ];\n  }\n\n  /**\n   * @param {Object} object Object.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @protected\n   * @return {import(\"../Feature.js\").default} Feature.\n   */\n  readFeatureFromObject(object, options) {\n    /**\n     * @type {GeoJSONFeature}\n     */\n    let geoJSONFeature = null;\n    if (object['type'] === 'Feature') {\n      geoJSONFeature = /** @type {GeoJSONFeature} */ (object);\n    } else {\n      geoJSONFeature = {\n        'type': 'Feature',\n        'geometry': /** @type {GeoJSONGeometry} */ (object),\n        'properties': null,\n      };\n    }\n\n    const geometry = readGeometry(geoJSONFeature['geometry'], options);\n    const feature = new Feature();\n    if (this.geometryName_) {\n      feature.setGeometryName(this.geometryName_);\n    } else if (\n      this.extractGeometryName_ &&\n      'geometry_name' in geoJSONFeature !== undefined\n    ) {\n      feature.setGeometryName(geoJSONFeature['geometry_name']);\n    }\n    feature.setGeometry(geometry);\n\n    if ('id' in geoJSONFeature) {\n      feature.setId(geoJSONFeature['id']);\n    }\n\n    if (geoJSONFeature['properties']) {\n      feature.setProperties(geoJSONFeature['properties'], true);\n    }\n    return feature;\n  }\n\n  /**\n   * @param {Object} object Object.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @protected\n   * @return {Array<Feature>} Features.\n   */\n  readFeaturesFromObject(object, options) {\n    const geoJSONObject = /** @type {GeoJSONObject} */ (object);\n    /** @type {Array<import(\"../Feature.js\").default>} */\n    let features = null;\n    if (geoJSONObject['type'] === 'FeatureCollection') {\n      const geoJSONFeatureCollection = /** @type {GeoJSONFeatureCollection} */ (\n        object\n      );\n      features = [];\n      const geoJSONFeatures = geoJSONFeatureCollection['features'];\n      for (let i = 0, ii = geoJSONFeatures.length; i < ii; ++i) {\n        features.push(this.readFeatureFromObject(geoJSONFeatures[i], options));\n      }\n    } else {\n      features = [this.readFeatureFromObject(object, options)];\n    }\n    return features;\n  }\n\n  /**\n   * @param {GeoJSONGeometry} object Object.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @protected\n   * @return {import(\"../geom/Geometry.js\").default} Geometry.\n   */\n  readGeometryFromObject(object, options) {\n    return readGeometry(object, options);\n  }\n\n  /**\n   * @param {Object} object Object.\n   * @protected\n   * @return {import(\"../proj/Projection.js\").default} Projection.\n   */\n  readProjectionFromObject(object) {\n    const crs = object['crs'];\n    let projection;\n    if (crs) {\n      if (crs['type'] == 'name') {\n        projection = getProjection(crs['properties']['name']);\n      } else if (crs['type'] === 'EPSG') {\n        projection = getProjection('EPSG:' + crs['properties']['code']);\n      } else {\n        assert(false, 36); // Unknown SRS type\n      }\n    } else {\n      projection = this.dataProjection;\n    }\n    return /** @type {import(\"../proj/Projection.js\").default} */ (projection);\n  }\n\n  /**\n   * Encode a feature as a GeoJSON Feature object.\n   *\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n   * @return {GeoJSONFeature} Object.\n   * @api\n   */\n  writeFeatureObject(feature, options) {\n    options = this.adaptOptions(options);\n\n    /** @type {GeoJSONFeature} */\n    const object = {\n      'type': 'Feature',\n      geometry: null,\n      properties: null,\n    };\n\n    const id = feature.getId();\n    if (id !== undefined) {\n      object.id = id;\n    }\n\n    if (!feature.hasProperties()) {\n      return object;\n    }\n\n    const properties = feature.getProperties();\n    const geometry = feature.getGeometry();\n    if (geometry) {\n      object.geometry = writeGeometry(geometry, options);\n\n      delete properties[feature.getGeometryName()];\n    }\n\n    if (!isEmpty(properties)) {\n      object.properties = properties;\n    }\n\n    return object;\n  }\n\n  /**\n   * Encode an array of features as a GeoJSON object.\n   *\n   * @param {Array<import(\"../Feature.js\").default>} features Features.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n   * @return {GeoJSONFeatureCollection} GeoJSON Object.\n   * @api\n   */\n  writeFeaturesObject(features, options) {\n    options = this.adaptOptions(options);\n    const objects = [];\n    for (let i = 0, ii = features.length; i < ii; ++i) {\n      objects.push(this.writeFeatureObject(features[i], options));\n    }\n    return {\n      type: 'FeatureCollection',\n      features: objects,\n    };\n  }\n\n  /**\n   * Encode a geometry as a GeoJSON object.\n   *\n   * @param {import(\"../geom/Geometry.js\").default} geometry Geometry.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n   * @return {GeoJSONGeometry|GeoJSONGeometryCollection} Object.\n   * @api\n   */\n  writeGeometryObject(geometry, options) {\n    return writeGeometry(geometry, this.adaptOptions(options));\n  }\n}\n\n/**\n * @param {GeoJSONGeometry|GeoJSONGeometryCollection} object Object.\n * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n * @return {import(\"../geom/Geometry.js\").default} Geometry.\n */\nfunction readGeometry(object, options) {\n  if (!object) {\n    return null;\n  }\n\n  /**\n   * @type {import(\"../geom/Geometry.js\").default}\n   */\n  let geometry;\n  switch (object['type']) {\n    case 'Point': {\n      geometry = readPointGeometry(/** @type {GeoJSONPoint} */ (object));\n      break;\n    }\n    case 'LineString': {\n      geometry = readLineStringGeometry(\n        /** @type {GeoJSONLineString} */ (object)\n      );\n      break;\n    }\n    case 'Polygon': {\n      geometry = readPolygonGeometry(/** @type {GeoJSONPolygon} */ (object));\n      break;\n    }\n    case 'MultiPoint': {\n      geometry = readMultiPointGeometry(\n        /** @type {GeoJSONMultiPoint} */ (object)\n      );\n      break;\n    }\n    case 'MultiLineString': {\n      geometry = readMultiLineStringGeometry(\n        /** @type {GeoJSONMultiLineString} */ (object)\n      );\n      break;\n    }\n    case 'MultiPolygon': {\n      geometry = readMultiPolygonGeometry(\n        /** @type {GeoJSONMultiPolygon} */ (object)\n      );\n      break;\n    }\n    case 'GeometryCollection': {\n      geometry = readGeometryCollectionGeometry(\n        /** @type {GeoJSONGeometryCollection} */ (object)\n      );\n      break;\n    }\n    default: {\n      throw new Error('Unsupported GeoJSON type: ' + object['type']);\n    }\n  }\n  return transformGeometryWithOptions(geometry, false, options);\n}\n\n/**\n * @param {GeoJSONGeometryCollection} object Object.\n * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n * @return {GeometryCollection} Geometry collection.\n */\nfunction readGeometryCollectionGeometry(object, options) {\n  const geometries = object['geometries'].map(\n    /**\n     * @param {GeoJSONGeometry} geometry Geometry.\n     * @return {import(\"../geom/Geometry.js\").default} geometry Geometry.\n     */\n    function (geometry) {\n      return readGeometry(geometry, options);\n    }\n  );\n  return new GeometryCollection(geometries);\n}\n\n/**\n * @param {GeoJSONPoint} object Object.\n * @return {Point} Point.\n */\nfunction readPointGeometry(object) {\n  return new Point(object['coordinates']);\n}\n\n/**\n * @param {GeoJSONLineString} object Object.\n * @return {LineString} LineString.\n */\nfunction readLineStringGeometry(object) {\n  return new LineString(object['coordinates']);\n}\n\n/**\n * @param {GeoJSONMultiLineString} object Object.\n * @return {MultiLineString} MultiLineString.\n */\nfunction readMultiLineStringGeometry(object) {\n  return new MultiLineString(object['coordinates']);\n}\n\n/**\n * @param {GeoJSONMultiPoint} object Object.\n * @return {MultiPoint} MultiPoint.\n */\nfunction readMultiPointGeometry(object) {\n  return new MultiPoint(object['coordinates']);\n}\n\n/**\n * @param {GeoJSONMultiPolygon} object Object.\n * @return {MultiPolygon} MultiPolygon.\n */\nfunction readMultiPolygonGeometry(object) {\n  return new MultiPolygon(object['coordinates']);\n}\n\n/**\n * @param {GeoJSONPolygon} object Object.\n * @return {Polygon} Polygon.\n */\nfunction readPolygonGeometry(object) {\n  return new Polygon(object['coordinates']);\n}\n\n/**\n * @param {import(\"../geom/Geometry.js\").default} geometry Geometry.\n * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n * @return {GeoJSONGeometry} GeoJSON geometry.\n */\nfunction writeGeometry(geometry, options) {\n  geometry = transformGeometryWithOptions(geometry, true, options);\n  const type = geometry.getType();\n\n  /** @type {GeoJSONGeometry} */\n  let geoJSON;\n  switch (type) {\n    case 'Point': {\n      geoJSON = writePointGeometry(/** @type {Point} */ (geometry), options);\n      break;\n    }\n    case 'LineString': {\n      geoJSON = writeLineStringGeometry(\n        /** @type {LineString} */ (geometry),\n        options\n      );\n      break;\n    }\n    case 'Polygon': {\n      geoJSON = writePolygonGeometry(\n        /** @type {Polygon} */ (geometry),\n        options\n      );\n      break;\n    }\n    case 'MultiPoint': {\n      geoJSON = writeMultiPointGeometry(\n        /** @type {MultiPoint} */ (geometry),\n        options\n      );\n      break;\n    }\n    case 'MultiLineString': {\n      geoJSON = writeMultiLineStringGeometry(\n        /** @type {MultiLineString} */ (geometry),\n        options\n      );\n      break;\n    }\n    case 'MultiPolygon': {\n      geoJSON = writeMultiPolygonGeometry(\n        /** @type {MultiPolygon} */ (geometry),\n        options\n      );\n      break;\n    }\n    case 'GeometryCollection': {\n      geoJSON = writeGeometryCollectionGeometry(\n        /** @type {GeometryCollection} */ (geometry),\n        options\n      );\n      break;\n    }\n    case 'Circle': {\n      geoJSON = {\n        type: 'GeometryCollection',\n        geometries: [],\n      };\n      break;\n    }\n    default: {\n      throw new Error('Unsupported geometry type: ' + type);\n    }\n  }\n  return geoJSON;\n}\n\n/**\n * @param {GeometryCollection} geometry Geometry.\n * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n * @return {GeoJSONGeometryCollection} GeoJSON geometry collection.\n */\nfunction writeGeometryCollectionGeometry(geometry, options) {\n  options = Object.assign({}, options);\n  delete options.featureProjection;\n  const geometries = geometry.getGeometriesArray().map(function (geometry) {\n    return writeGeometry(geometry, options);\n  });\n  return {\n    type: 'GeometryCollection',\n    geometries: geometries,\n  };\n}\n\n/**\n * @param {LineString} geometry Geometry.\n * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n * @return {GeoJSONGeometry} GeoJSON geometry.\n */\nfunction writeLineStringGeometry(geometry, options) {\n  return {\n    type: 'LineString',\n    coordinates: geometry.getCoordinates(),\n  };\n}\n\n/**\n * @param {MultiLineString} geometry Geometry.\n * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n * @return {GeoJSONGeometry} GeoJSON geometry.\n */\nfunction writeMultiLineStringGeometry(geometry, options) {\n  return {\n    type: 'MultiLineString',\n    coordinates: geometry.getCoordinates(),\n  };\n}\n\n/**\n * @param {MultiPoint} geometry Geometry.\n * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n * @return {GeoJSONGeometry} GeoJSON geometry.\n */\nfunction writeMultiPointGeometry(geometry, options) {\n  return {\n    type: 'MultiPoint',\n    coordinates: geometry.getCoordinates(),\n  };\n}\n\n/**\n * @param {MultiPolygon} geometry Geometry.\n * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n * @return {GeoJSONGeometry} GeoJSON geometry.\n */\nfunction writeMultiPolygonGeometry(geometry, options) {\n  let right;\n  if (options) {\n    right = options.rightHanded;\n  }\n  return {\n    type: 'MultiPolygon',\n    coordinates: geometry.getCoordinates(right),\n  };\n}\n\n/**\n * @param {Point} geometry Geometry.\n * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n * @return {GeoJSONGeometry} GeoJSON geometry.\n */\nfunction writePointGeometry(geometry, options) {\n  return {\n    type: 'Point',\n    coordinates: geometry.getCoordinates(),\n  };\n}\n\n/**\n * @param {Polygon} geometry Geometry.\n * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n * @return {GeoJSONGeometry} GeoJSON geometry.\n */\nfunction writePolygonGeometry(geometry, options) {\n  let right;\n  if (options) {\n    right = options.rightHanded;\n  }\n  return {\n    type: 'Polygon',\n    coordinates: geometry.getCoordinates(right),\n  };\n}\n\nexport default GeoJSON;\n","/**\n * @module ol/renderer/canvas/VectorImageLayer\n */\nimport CanvasImageLayerRenderer from './ImageLayer.js';\nimport CanvasVectorLayerRenderer from './VectorLayer.js';\nimport EventType from '../../events/EventType.js';\nimport ImageCanvas from '../../ImageCanvas.js';\nimport ImageState from '../../ImageState.js';\nimport RBush from 'rbush';\nimport ViewHint from '../../ViewHint.js';\nimport {apply, compose, create} from '../../transform.js';\nimport {getHeight, getWidth, isEmpty, scaleFromCenter} from '../../extent.js';\n\n/**\n * @classdesc\n * Canvas renderer for image layers.\n * @api\n */\nclass CanvasVectorImageLayerRenderer extends CanvasImageLayerRenderer {\n  /**\n   * @param {import(\"../../layer/VectorImage.js\").default} layer Vector image layer.\n   */\n  constructor(layer) {\n    super(layer);\n\n    /**\n     * @private\n     * @type {import(\"./VectorLayer.js\").default}\n     */\n    this.vectorRenderer_ = new CanvasVectorLayerRenderer(layer);\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.layerImageRatio_ = layer.getImageRatio();\n\n    /**\n     * @private\n     * @type {import(\"../../transform.js\").Transform}\n     */\n    this.coordinateToVectorPixelTransform_ = create();\n\n    /**\n     * @private\n     * @type {import(\"../../transform.js\").Transform}\n     */\n    this.renderedPixelToCoordinateTransform_ = null;\n  }\n\n  /**\n   * Clean up.\n   */\n  disposeInternal() {\n    this.vectorRenderer_.dispose();\n    super.disposeInternal();\n  }\n\n  /**\n   * Asynchronous layer level hit detection.\n   * @param {import(\"../../pixel.js\").Pixel} pixel Pixel.\n   * @return {Promise<Array<import(\"../../Feature\").default>>} Promise that resolves with an array of features.\n   */\n  getFeatures(pixel) {\n    if (!this.vectorRenderer_) {\n      return Promise.resolve([]);\n    }\n    const vectorPixel = apply(\n      this.coordinateToVectorPixelTransform_,\n      apply(this.renderedPixelToCoordinateTransform_, pixel.slice())\n    );\n    return this.vectorRenderer_.getFeatures(vectorPixel);\n  }\n\n  /**\n   * Perform action necessary to get the layer rendered after new fonts have loaded\n   */\n  handleFontsChanged() {\n    this.vectorRenderer_.handleFontsChanged();\n  }\n\n  /**\n   * Determine whether render should be called.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   */\n  prepareFrame(frameState) {\n    const pixelRatio = frameState.pixelRatio;\n    const viewState = frameState.viewState;\n    const viewResolution = viewState.resolution;\n\n    const hints = frameState.viewHints;\n    const vectorRenderer = this.vectorRenderer_;\n    let renderedExtent = frameState.extent;\n    if (this.layerImageRatio_ !== 1) {\n      renderedExtent = renderedExtent.slice(0);\n      scaleFromCenter(renderedExtent, this.layerImageRatio_);\n    }\n    const width = getWidth(renderedExtent) / viewResolution;\n    const height = getHeight(renderedExtent) / viewResolution;\n\n    if (\n      !hints[ViewHint.ANIMATING] &&\n      !hints[ViewHint.INTERACTING] &&\n      !isEmpty(renderedExtent)\n    ) {\n      vectorRenderer.useContainer(null, null);\n      const context = vectorRenderer.context;\n      const layerState = frameState.layerStatesArray[frameState.layerIndex];\n      const imageLayerState = Object.assign({}, layerState, {opacity: 1});\n      const imageFrameState = /** @type {import(\"../../Map.js\").FrameState} */ (\n        Object.assign({}, frameState, {\n          declutterTree: new RBush(9),\n          extent: renderedExtent,\n          size: [width, height],\n          viewState: /** @type {import(\"../../View.js\").State} */ (\n            Object.assign({}, frameState.viewState, {\n              rotation: 0,\n            })\n          ),\n          layerStatesArray: [imageLayerState],\n          layerIndex: 0,\n        })\n      );\n      let emptyImage = true;\n      const image = new ImageCanvas(\n        renderedExtent,\n        viewResolution,\n        pixelRatio,\n        context.canvas,\n        function (callback) {\n          if (\n            vectorRenderer.prepareFrame(imageFrameState) &&\n            vectorRenderer.replayGroupChanged\n          ) {\n            vectorRenderer.clipping = false;\n            if (vectorRenderer.renderFrame(imageFrameState, null)) {\n              vectorRenderer.renderDeclutter(imageFrameState);\n              emptyImage = false;\n            }\n            callback();\n          }\n        }\n      );\n\n      image.addEventListener(EventType.CHANGE, () => {\n        if (image.getState() !== ImageState.LOADED) {\n          return;\n        }\n        this.image_ = emptyImage ? null : image;\n        const imageResolution = image.getResolution();\n        const imagePixelRatio = image.getPixelRatio();\n        const renderedResolution =\n          (imageResolution * pixelRatio) / imagePixelRatio;\n        this.renderedResolution = renderedResolution;\n        this.coordinateToVectorPixelTransform_ = compose(\n          this.coordinateToVectorPixelTransform_,\n          width / 2,\n          height / 2,\n          1 / renderedResolution,\n          -1 / renderedResolution,\n          0,\n          -viewState.center[0],\n          -viewState.center[1]\n        );\n      });\n      image.load();\n    }\n\n    if (this.image_) {\n      this.renderedPixelToCoordinateTransform_ =\n        frameState.pixelToCoordinateTransform.slice();\n    }\n\n    return !!this.image_;\n  }\n\n  /**\n   */\n  preRender() {}\n\n  /**\n   */\n  postRender() {}\n\n  /**\n   */\n  renderDeclutter() {}\n\n  /**\n   * @param {import(\"../../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {number} hitTolerance Hit tolerance in pixels.\n   * @param {import(\"../vector.js\").FeatureCallback<T>} callback Feature callback.\n   * @param {Array<import(\"../Map.js\").HitMatch<T>>} matches The hit detected matches with tolerance.\n   * @return {T|undefined} Callback result.\n   * @template T\n   */\n  forEachFeatureAtCoordinate(\n    coordinate,\n    frameState,\n    hitTolerance,\n    callback,\n    matches\n  ) {\n    if (this.vectorRenderer_) {\n      return this.vectorRenderer_.forEachFeatureAtCoordinate(\n        coordinate,\n        frameState,\n        hitTolerance,\n        callback,\n        matches\n      );\n    }\n    return super.forEachFeatureAtCoordinate(\n      coordinate,\n      frameState,\n      hitTolerance,\n      callback,\n      matches\n    );\n  }\n}\n\nexport default CanvasVectorImageLayerRenderer;\n","/**\n * @module ol/layer/VectorImage\n */\nimport BaseVectorLayer from './BaseVector.js';\nimport CanvasVectorImageLayerRenderer from '../renderer/canvas/VectorImageLayer.js';\n\n/**\n * @template {import(\"../source/Vector.js\").default} VectorSourceType\n * @typedef {Object} Options\n * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.\n * @property {number} [opacity=1] Opacity (0, 1).\n * @property {boolean} [visible=true] Visibility.\n * @property {import(\"../extent.js\").Extent} [extent] The bounding extent for layer rendering.  The layer will not be\n * rendered outside of this extent.\n * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers\n * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed\n * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`\n * method was used.\n * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be\n * visible.\n * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will\n * be visible.\n * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be\n * visible.\n * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will\n * be visible.\n * @property {import(\"../render.js\").OrderFunction} [renderOrder] Render order. Function to be used when sorting\n * features before rendering. By default features are drawn in the order that they are created. Use\n * `null` to avoid the sort, but get an undefined draw order.\n * @property {number} [renderBuffer=100] The buffer in pixels around the viewport extent used by the\n * renderer when getting features from the vector source for the rendering or hit-detection.\n * Recommended value: the size of the largest symbol, line width or label.\n * @property {VectorSourceType} [source] Source.\n * @property {import(\"../Map.js\").default} [map] Sets the layer as overlay on a map. The map will not manage\n * this layer in its layers collection, and the layer will be rendered on top. This is useful for\n * temporary layers. The standard way to add a layer to a map and have it managed by the map is to\n * use [map.addLayer()]{@link import(\"../Map.js\").default#addLayer}.\n * @property {boolean} [declutter=false] Declutter images and text on this layer. The priority is defined\n * by the `zIndex` of the style and the render order of features. Higher z-index means higher priority.\n * Within the same z-index, a feature rendered before another has higher priority.\n * @property {import(\"../style/Style.js\").StyleLike|null} [style] Layer style. When set to `null`, only\n * features that have their own style will be rendered. See {@link module:ol/style/Style~Style} for the default style\n * which will be used if this is not set.\n * @property {number} [imageRatio=1] Ratio by which the rendered extent should be larger than the\n * viewport extent. A larger ratio avoids cut images during panning, but will cause a decrease in performance.\n * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.\n */\n\n/**\n * @classdesc\n * Vector data is rendered client-side, to an image. This layer type provides great performance\n * during panning and zooming, but point symbols and texts are always rotated with the view and\n * pixels are scaled during zoom animations. For more accurate rendering of vector data, use\n * {@link module:ol/layer/Vector~VectorLayer} instead.\n *\n * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}\n * property on the layer object; for example, setting `title: 'My Title'` in the\n * options means that `title` is observable, and has get/set accessors.\n *\n * @template {import(\"../source/Vector.js\").default} VectorSourceType\n * @extends {BaseVectorLayer<VectorSourceType, CanvasVectorImageLayerRenderer>}\n * @api\n */\nclass VectorImageLayer extends BaseVectorLayer {\n  /**\n   * @param {Options<VectorSourceType>} [options] Options.\n   */\n  constructor(options) {\n    options = options ? options : {};\n\n    const baseOptions = Object.assign({}, options);\n    delete baseOptions.imageRatio;\n    super(baseOptions);\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.imageRatio_ =\n      options.imageRatio !== undefined ? options.imageRatio : 1;\n  }\n\n  /**\n   * @return {number} Ratio between rendered extent size and viewport extent size.\n   */\n  getImageRatio() {\n    return this.imageRatio_;\n  }\n\n  createRenderer() {\n    return new CanvasVectorImageLayerRenderer(this);\n  }\n}\n\nexport default VectorImageLayer;\n","import { useEffect } from \"react\";\nimport { useMap } from \"../../contexts/mapContext\";\nimport { FeatureCollection } from \"geojson\";\nimport VectorSource from \"ol/source/Vector\";\nimport GeoJSON from \"ol/format/GeoJSON\";\nimport VectorImageLayer from \"ol/layer/VectorImage\";\nimport Style from \"ol/style/Style\";\nimport Fill, { Options as FillOptions } from \"ol/style/Fill\";\nimport Stroke, { Options as StrokeOptions } from \"ol/style/Stroke\";\nimport { useRef } from \"preact/hooks\";\nimport BaseLayer from \"ol/layer/Base\";\n\ninterface MapLayerProps {\n  features: FeatureCollection;\n  stroke: StrokeOptions;\n  fill: FillOptions;\n  zIndex: number;\n}\n\nconst MapLayer = ({ features, stroke, fill, zIndex = 1 }: MapLayerProps) => {\n  const map = useMap();\n  const layer = useRef<BaseLayer | null>(null);\n\n  useEffect(() => {\n    if (layer.current) {\n      map.removeLayer(layer.current);\n      layer.current = null;\n    }\n\n    const source = new VectorSource({\n      features: new GeoJSON().readFeatures(features),\n    });\n    layer.current = new VectorImageLayer({\n      source,\n      style: new Style({\n        fill: new Fill(fill),\n        stroke: new Stroke(stroke),\n      }),\n    });\n\n    layer.current.setZIndex(zIndex);\n    map.addLayer(layer.current);\n\n    return () => {\n      layer.current && map?.removeLayer(layer.current);\n    };\n  }, [features, map, layer, stroke, fill]);\n\n  return null;\n};\n\nexport default MapLayer;\n"],"names":["ImageBase","EventTarget","extent","resolution","pixelRatio","state","EventType","abstract","ImageBase$1","ImageCanvas","canvas","loader","ImageState","err","ImageCanvas$1","CanvasImageLayerRenderer","CanvasLayerRenderer","imageLayer","frameState","layerState","viewState","viewResolution","imageSource","hints","renderedExtent","getIntersection","fromUserExtent","ViewHint","isEmpty","projection","image","pixel","layer","coordinate","applyTransform","layerExtent","containsCoordinate","imageExtent","img","imageMapWidth","getWidth","col","imageMapHeight","getHeight","row","target","imageResolution","imagePixelRatio","viewCenter","scale","rotation","width","height","composeTransform","makeInverse","canvasTransform","toTransformString","context","clipped","render","intersectsExtent","containsExtent","transform","dw","dh","dx","dy","opacity","previousAlpha","CanvasImageLayerRenderer$1","FeatureFormat","source","options","dataProjection","getProjection","feature","features","geometry","transformGeometryWithOptions","write","featureProjection","transformed","equivalentProjection","power","coordinates","i","ii","JSONFeature","getObject","object","JSONFeature$1","GeoJSON","geoJSONFeature","readGeometry","Feature","geoJSONObject","geoJSONFeatureCollection","geoJSONFeatures","crs","assert","id","properties","writeGeometry","objects","readPointGeometry","readLineStringGeometry","readPolygonGeometry","readMultiPointGeometry","readMultiLineStringGeometry","readMultiPolygonGeometry","readGeometryCollectionGeometry","geometries","GeometryCollection","Point","LineString","MultiLineString","MultiPoint","MultiPolygon","Polygon","type","geoJSON","writePointGeometry","writeLineStringGeometry","writePolygonGeometry","writeMultiPointGeometry","writeMultiLineStringGeometry","writeMultiPolygonGeometry","writeGeometryCollectionGeometry","right","GeoJSON$1","CanvasVectorImageLayerRenderer","CanvasVectorLayerRenderer","create","vectorPixel","apply","vectorRenderer","scaleFromCenter","imageLayerState","imageFrameState","RBush","emptyImage","callback","renderedResolution","compose","hitTolerance","matches","CanvasVectorImageLayerRenderer$1","VectorImageLayer","BaseVectorLayer","baseOptions","VectorImageLayer$1","MapLayer","stroke","fill","zIndex","map","useMap","useRef","useEffect","current","removeLayer","VectorSource","readFeatures","style","Style","Fill","Stroke","setZIndex","addLayer"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7]}